
// ai2html.js
var scriptVersion     = "0.62";
var scriptEnvironment = "nyt";  // TODO: detect this setting

// ai2html is a script for Adobe Illustrator that converts your Illustrator document into html and css.

// Copyright (c) 2011-2015 The New York Times Company
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this library except in compliance with the License.
// You may obtain a copy of the License at

// http://www.apache.org/licenses/LICENSE-2.0

// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

// =====================================
// How to install ai2html
// =====================================

// - Move the ai2html.js file into the Illustrator folder where scripts are located.
// - For example, on Mac OS X running Adobe Illustrator CC 2014, the path would be: // Adobe Illustrator CC 2014/Presets/en_US/Scripts/ai2html.jsx

// =====================================
// How to use ai2html
// =====================================

// - Create your Illustrator artwork.
// - Size the artboard to the dimensions that you want the div to appear on the web page.
// - Make sure your Document Color Mode is set to RGB.
// - Make sure your document is saved.
// - Use Arial or Georgia unless you have added your own fonts to the fonts array in the script.
// - Run the script by choosing: File > Scripts > ai2html
// - Go to the folder containing your Illustrator file. Inside will be a folder called ai2html-output.
// - Open the html files in your browser to preview your output.


// ================================================
// ai2html and config settings
// ================================================

// Settings can be generated by making a copy of this Google Spreadsheet:
// https://docs.google.com/spreadsheets/d/13ESQ9ktfkdzFq78FkWLGaZr2s3lNbv2cN25F2pYf5XM/edit?usp=sharing
// Make a copy of the spreadsheet for yourself.
// Modify the settings to taste.
// Copy the contents from column Images and replace the settings statements:
var nytBaseSettings = {
  ai2html_environment: {defaultValue: scriptEnvironment, includeInSettingsBlock: false, includeInConfigFile: false, useQuoteMarksInConfigFile: false, inputType: "text", possibleValues: "", notes: ""},
  settings_version: {defaultValue: scriptVersion, includeInSettingsBlock: true, includeInConfigFile: false, useQuoteMarksInConfigFile: false, inputType: "text", possibleValues: "", notes: ""},
  create_promo_image: {defaultValue: "yes", includeInSettingsBlock: true, includeInConfigFile: false, useQuoteMarksInConfigFile: false, inputType: "text", possibleValues: "", notes: ""},
  image_format: {defaultValue: ["png"], includeInSettingsBlock: true, includeInConfigFile: false, useQuoteMarksInConfigFile: false, inputType: "array", possibleValues: "jpg, png, png24", notes: "Images will be generated in mulitple formats if multiple formats are listed, separated by commas. The first format will be used in the html. Sometimes this is useful to compare which format will have a smaller file size."},
  write_image_files: {defaultValue: "yes", includeInSettingsBlock: true, includeInConfigFile: false, useQuoteMarksInConfigFile: false, inputType: "yesNo", possibleValues: "", notes: "Set this to \u201Cno\u201D to skip writing the image files. Generally only use this after you have run the script once with this setting set to \u201Cyes.\u201D"},
  responsiveness: {defaultValue: "fixed", includeInSettingsBlock: true, includeInConfigFile: false, useQuoteMarksInConfigFile: false, inputType: "text", possibleValues: "fixed, dynamic", notes: "Dynamic responsiveness means ai graphics will scale to fill the container they are placed in."},
  max_width: {defaultValue: "", includeInSettingsBlock: true, includeInConfigFile: false, useQuoteMarksInConfigFile: false, inputType: "integer", possibleValues: "", notes: "Blank or any positive number in pixels, but do not write \u201Cpx\u201D - blank means artboards will set max size, instead it is written to the config file so that the max width can be applied to the template’s container."},
  output: {defaultValue: "one-file", includeInSettingsBlock: true, includeInConfigFile: false, useQuoteMarksInConfigFile: false, inputType: "text", possibleValues: "one-file, multiple-files", notes: "One html file containing all the artboards or a separate html file for each artboard."},
  project_name: {defaultValue: "", includeInSettingsBlock: false, includeInConfigFile: false, useQuoteMarksInConfigFile: false, inputType: "text", possibleValues: "", notes: "Use this to set a custom project name. The project name is being used in output filenames, class names, etc."},
  html_output_path: {defaultValue: "../src/", includeInSettingsBlock: false, includeInConfigFile: false, useQuoteMarksInConfigFile: false, inputType: "folderPath", possibleValues: "", notes: "Allows user to change folder to write html files, path should be written relative to ai file location. This is ignored if the project_type in the yml is ai2html."},
  html_output_extension: {defaultValue: ".html", includeInSettingsBlock: false, includeInConfigFile: false, useQuoteMarksInConfigFile: false, inputType: "fileExtension", possibleValues: "", notes: "This is ignored if the project_type in the yml is ai2html."},
  image_output_path: {defaultValue: "../public/_assets/", includeInSettingsBlock: false, includeInConfigFile: false, useQuoteMarksInConfigFile: false, inputType: "folderPath", possibleValues: "", notes: "_assets/ for preview default. This is where the image files get written to locally and should be written as if the html_output location is the starting point."},
  image_source_path: {defaultValue: null, includeInSettingsBlock: false, includeInConfigFile: false, useQuoteMarksInConfigFile: false, inputType: "folderPath", possibleValues: "", notes: "Use this setting to specify from where the images are being loaded from the HTML file. Defaults to image_output_path"},
  create_config_file: {defaultValue: "true", includeInSettingsBlock: false, includeInConfigFile: false, useQuoteMarksInConfigFile: false, inputType: "trueFalse", possibleValues: "", notes: "This is ignored in env=nyt."},
  config_file_path: {defaultValue: "../config.yml", includeInSettingsBlock: false, includeInConfigFile: false, useQuoteMarksInConfigFile: false, inputType: "filePath", possibleValues: "", notes: "This only gets used to write the config file. It’s not used in the nyt mode to read the config.yml. Path should written relative to the ai file location."},
  local_preview_template: {defaultValue: "", includeInSettingsBlock: false, includeInConfigFile: false, useQuoteMarksInConfigFile: false, inputType: "filePath", possibleValues: "", notes: ""},
  png_transparent: {defaultValue: "no", includeInSettingsBlock: false, includeInConfigFile: false, useQuoteMarksInConfigFile: false, inputType: "yesNo", possibleValues: "", notes: ""},
  png_number_of_colors: {defaultValue: 128, includeInSettingsBlock: true, includeInConfigFile: false, useQuoteMarksInConfigFile: false, inputType: "integer", possibleValues: "2 to 256", notes: ""},
  jpg_quality: {defaultValue: 60, includeInSettingsBlock: true, includeInConfigFile: false, useQuoteMarksInConfigFile: false, inputType: "integer", possibleValues: "0 to 100", notes: ""},
  center_html_output: {defaultValue: "true", includeInSettingsBlock: false, includeInConfigFile: false, useQuoteMarksInConfigFile: false, inputType: "text", possibleValues: "", notes: "Adds \u201Cmargin:0 auto;\u201D to the div containing the ai2html output."},
  use_2x_images_if_possible: {defaultValue: "yes", includeInSettingsBlock: false, includeInConfigFile: false, useQuoteMarksInConfigFile: false, inputType: "yesNo", possibleValues: "", notes: ""},
  use_lazy_loader: {defaultValue: "yes", includeInSettingsBlock: false, includeInConfigFile: false, useQuoteMarksInConfigFile: false, inputType: "yesNo", possibleValues: "", notes: ""},
  include_resizer_css_js: {defaultValue: "yes", includeInSettingsBlock: false, includeInConfigFile: false, useQuoteMarksInConfigFile: false, inputType: "yesNo", possibleValues: "", notes: ""},
  include_resizer_classes: {defaultValue: "no", includeInSettingsBlock: false, includeInConfigFile: false, useQuoteMarksInConfigFile: false, inputType: "yesNo", possibleValues: "", notes: ""},
  include_resizer_widths: {defaultValue: "yes", includeInSettingsBlock: false, includeInConfigFile: false, useQuoteMarksInConfigFile: false, inputType: "yesNo", possibleValues: "", notes: ""},
  include_resizer_script: {defaultValue: "yes", includeInSettingsBlock: false, includeInConfigFile: false, useQuoteMarksInConfigFile: false, inputType: "yesNo", possibleValues: "", notes: ""},
  svg_embed_images: {defaultValue: "no", includeInSettingsBlock: false, includeInConfigFile: false, useQuoteMarksInConfigFile: false, inputType: "yesNo", possibleValues: "", notes: ""},
  render_rotated_skewed_text_as: {defaultValue: "html", includeInSettingsBlock: false, includeInConfigFile: false, useQuoteMarksInConfigFile: false, inputType: "text", possibleValues: "image, html", notes: ""},
  show_completion_dialog_box: {defaultValue: "true", includeInSettingsBlock: true, includeInConfigFile: false, useQuoteMarksInConfigFile: false, inputType: "trueFalse", possibleValues: "", notes: "Set this to false if you don't want to see the dialog box confirming completion of the script."},
  clickable_link: {defaultValue: "", includeInSettingsBlock: false, includeInConfigFile: false, useQuoteMarksInConfigFile: false, inputType: "text", possibleValues: "", notes: "If you put a url in this field, an <a> tag will be added, wrapping around the output and pointing to that url."},
  testing_mode: {defaultValue: "no", includeInSettingsBlock: false, includeInConfigFile: false, useQuoteMarksInConfigFile: false, inputType: "yesNo", possibleValues: "", notes: ""},
  last_updated_text: {defaultValue: "", includeInSettingsBlock: true, includeInConfigFile: true, useQuoteMarksInConfigFile: true, inputType: "text", possibleValues: "", notes: ""},
  headline: {defaultValue: "", includeInSettingsBlock: true, includeInConfigFile: true, useQuoteMarksInConfigFile: true, inputType: "text", possibleValues: "", notes: ""},
  leadin: {defaultValue: "", includeInSettingsBlock: true, includeInConfigFile: true, useQuoteMarksInConfigFile: true, inputType: "text", possibleValues: "", notes: ""},
  summary: {defaultValue: "", includeInSettingsBlock: true, includeInConfigFile: true, useQuoteMarksInConfigFile: true, inputType: "text", possibleValues: "", notes: "Summary field for Scoop assets"},
  notes: {defaultValue: "", includeInSettingsBlock: true, includeInConfigFile: true, useQuoteMarksInConfigFile: true, inputType: "text", possibleValues: "", notes: ""},
  sources: {defaultValue: "", includeInSettingsBlock: true, includeInConfigFile: true, useQuoteMarksInConfigFile: true, inputType: "text", possibleValues: "", notes: ""},
  credit: {defaultValue: "By The New York Times", includeInSettingsBlock: true, includeInConfigFile: true, useQuoteMarksInConfigFile: true, inputType: "text", possibleValues: "", notes: ""},
  page_template: {defaultValue: "nyt5-article-embed", includeInSettingsBlock: true, includeInConfigFile: true, useQuoteMarksInConfigFile: false, inputType: "text", possibleValues: "", notes: ""},
  publish_system: {defaultValue: "scoop", includeInSettingsBlock: false, includeInConfigFile: true, useQuoteMarksInConfigFile: false, inputType: "text", possibleValues: "", notes: ""},
  environment: {defaultValue: "production", includeInSettingsBlock: false, includeInConfigFile: true, useQuoteMarksInConfigFile: false, inputType: "text", possibleValues: "", notes: ""},
  show_in_compatible_apps: {defaultValue: "yes", includeInSettingsBlock: true, includeInConfigFile: true, useQuoteMarksInConfigFile: true, inputType: "yesNo", possibleValues: "", notes: ""},
  display_for_promotion_only: {defaultValue: "false", includeInSettingsBlock: true, includeInConfigFile: true, useQuoteMarksInConfigFile: false, inputType: "trueFalse", possibleValues: "", notes: ""},
  constrain_width_to_text_column: {defaultValue: "false", includeInSettingsBlock: true, includeInConfigFile: true, useQuoteMarksInConfigFile: false, inputType: "trueFalse", possibleValues: "", notes: ""},
  scoop_publish_fields: {defaultValue: "true", includeInSettingsBlock: false, includeInConfigFile: true, useQuoteMarksInConfigFile: false, inputType: "trueFalse", possibleValues: "", notes: ""},
  scoop_asset_id: {defaultValue: "", includeInSettingsBlock: true, includeInConfigFile: true, useQuoteMarksInConfigFile: false, inputType: "text", possibleValues: "", notes: ""},
  scoop_username: {defaultValue: "", includeInSettingsBlock: true, includeInConfigFile: true, useQuoteMarksInConfigFile: false, inputType: "text", possibleValues: "", notes: ""},
  scoop_slug: {defaultValue: "", includeInSettingsBlock: true, includeInConfigFile: true, useQuoteMarksInConfigFile: false, inputType: "text", possibleValues: "", notes: ""},
  scoop_external_edit_key: {defaultValue: "", includeInSettingsBlock: true, includeInConfigFile: true, useQuoteMarksInConfigFile: false, inputType: "text", possibleValues: "", notes: ""}
};

var defaultBaseSettings = {
  ai2html_environment: {defaultValue: scriptEnvironment, includeInSettingsBlock: false, includeInConfigFile: false, useQuoteMarksInConfigFile: false, inputType: "text", possibleValues: "", notes: ""},
  settings_version: {defaultValue: scriptVersion, includeInSettingsBlock: true, includeInConfigFile: false, useQuoteMarksInConfigFile: false, inputType: "text", possibleValues: "", notes: ""},
  create_promo_image: {defaultValue: "no", includeInSettingsBlock: false, includeInConfigFile: false, useQuoteMarksInConfigFile: false, inputType: "text", possibleValues: "", notes: ""},
  image_format: {defaultValue: ["png"], includeInSettingsBlock: true, includeInConfigFile: false, useQuoteMarksInConfigFile: false, inputType: "array", possibleValues: "jpg, png, png24", notes: "Images will be generated in mulitple formats if multiple formats are listed, separated by commas. The first format will be used in the html. Sometimes this is useful to compare which format will have a smaller file size."},
  write_image_files: {defaultValue: "yes", includeInSettingsBlock: false, includeInConfigFile: false, useQuoteMarksInConfigFile: false, inputType: "yesNo", possibleValues: "", notes: "Set this to \u201Cno\u201D to skip writing the image files. Generally only use this after you have run the script once with this setting set to \u201Cyes.\u201D"},
  responsiveness: {defaultValue: "fixed", includeInSettingsBlock: true, includeInConfigFile: false, useQuoteMarksInConfigFile: false, inputType: "text", possibleValues: "fixed, dynamic", notes: "Dynamic responsiveness means ai graphics will scale to fill the container they are placed in."},
  max_width: {defaultValue: "", includeInSettingsBlock: false, includeInConfigFile: false, useQuoteMarksInConfigFile: false, inputType: "integer", possibleValues: "", notes: "Blank or any positive number in pixels, but do not write \u201Cpx\u201D - blank means artboards will set max size, the max width is not included in the html stub, instead it is written to the config file so that the max width can be applied to the template’s container."},
  output: {defaultValue: "one-file", includeInSettingsBlock: true, includeInConfigFile: false, useQuoteMarksInConfigFile: false, inputType: "text", possibleValues: "one-file, multiple-files", notes: "One html file containing all the artboards or a separate html file for each artboard."},
  project_name: {defaultValue: "", includeInSettingsBlock: false, includeInConfigFile: false, useQuoteMarksInConfigFile: false, inputType: "text", possibleValues: "", notes: "Use this to set a custom project name. The project name is being used in output filenames, class names, etc."},
  html_output_path: {defaultValue: "/ai2html-output/", includeInSettingsBlock: true, includeInConfigFile: false, useQuoteMarksInConfigFile: false, inputType: "folderPath", possibleValues: "", notes: "Allows user to change folder to write html files, path should be written relative to ai file location. This is ignored if the project_type in the yml is ai2html."},
  html_output_extension: {defaultValue: ".html", includeInSettingsBlock: true, includeInConfigFile: false, useQuoteMarksInConfigFile: false, inputType: "fileExtension", possibleValues: "", notes: "This is ignored if the project_type in the yml is ai2html."},
  image_output_path: {defaultValue: "", includeInSettingsBlock: true, includeInConfigFile: false, useQuoteMarksInConfigFile: false, inputType: "folderPath", possibleValues: "", notes: "This is where the image files get written to locally and should be written as if the html_output is the starting point."},
  image_source_path: {defaultValue: null, includeInSettingsBlock: false, includeInConfigFile: false, useQuoteMarksInConfigFile: false, inputType: "folderPath", possibleValues: "", notes: "Use this setting to specify from where the images are being loaded from the HTML file. Defaults to image_output_path"},
  create_config_file: {defaultValue: "false", includeInSettingsBlock: false, includeInConfigFile: false, useQuoteMarksInConfigFile: false, inputType: "trueFalse", possibleValues: "", notes: "This is ignored in env=nyt."},
  config_file_path: {defaultValue: "", includeInSettingsBlock: false, includeInConfigFile: false, useQuoteMarksInConfigFile: false, inputType: "filePath", possibleValues: "", notes: "This only gets used to write the config file. It’s not used in the nyt mode to read the config.yml. Path should written relative to the ai file location."},
  local_preview_template: {defaultValue: "", includeInSettingsBlock: true, includeInConfigFile: false, useQuoteMarksInConfigFile: false, inputType: "filePath", possibleValues: "", notes: ""},
  png_transparent: {defaultValue: "no", includeInSettingsBlock: false, includeInConfigFile: false, useQuoteMarksInConfigFile: false, inputType: "yesNo", possibleValues: "", notes: ""},
  png_number_of_colors: {defaultValue: 128, includeInSettingsBlock: true, includeInConfigFile: false, useQuoteMarksInConfigFile: false, inputType: "integer", possibleValues: "2 to 256", notes: ""},
  jpg_quality: {defaultValue: 60, includeInSettingsBlock: true, includeInConfigFile: false, useQuoteMarksInConfigFile: false, inputType: "integer", possibleValues: "0 to 100", notes: ""},
  center_html_output: {defaultValue: "true", includeInSettingsBlock: false, includeInConfigFile: false, useQuoteMarksInConfigFile: false, inputType: "text", possibleValues: "", notes: "Adds \u201Cmargin:0 auto;\u201D to the div containing the ai2html output."},
  use_2x_images_if_possible: {defaultValue: "yes", includeInSettingsBlock: false, includeInConfigFile: false, useQuoteMarksInConfigFile: false, inputType: "yesNo", possibleValues: "", notes: ""},
  use_lazy_loader: {defaultValue: "no", includeInSettingsBlock: false, includeInConfigFile: false, useQuoteMarksInConfigFile: false, inputType: "yesNo", possibleValues: "", notes: ""},
  include_resizer_css_js: {defaultValue: "no", includeInSettingsBlock: false, includeInConfigFile: false, useQuoteMarksInConfigFile: false, inputType: "yesNo", possibleValues: "", notes: ""},
  include_resizer_classes: {defaultValue: "no", includeInSettingsBlock: false, includeInConfigFile: false, useQuoteMarksInConfigFile: false, inputType: "yesNo", possibleValues: "", notes: ""},
  include_resizer_widths: {defaultValue: "yes", includeInSettingsBlock: false, includeInConfigFile: false, useQuoteMarksInConfigFile: false, inputType: "yesNo", possibleValues: "", notes: "If set to \u201Cyes\u201D, ai2html adds data-min-width and data-max-width attributes to each artboard"},
  include_resizer_script: {defaultValue: "no", includeInSettingsBlock: false, includeInConfigFile: false, useQuoteMarksInConfigFile: false, inputType: "yesNo", possibleValues: "", notes: ""},
  svg_embed_images: {defaultValue: "no", includeInSettingsBlock: false, includeInConfigFile: false, useQuoteMarksInConfigFile: false, inputType: "yesNo", possibleValues: "", notes: ""},
  render_rotated_skewed_text_as: {defaultValue: "html", includeInSettingsBlock: false, includeInConfigFile: false, useQuoteMarksInConfigFile: false, inputType: "text", possibleValues: "image, html", notes: ""},
  show_completion_dialog_box: {defaultValue: "yes", includeInSettingsBlock: false, includeInConfigFile: false, useQuoteMarksInConfigFile: false, inputType: "yesNo", possibleValues: "", notes: "Set this to \u201Cno\u201D if you don't want to see the dialog box confirming completion of the script."},
  clickable_link: {defaultValue: "", includeInSettingsBlock: false, includeInConfigFile: false, useQuoteMarksInConfigFile: false, inputType: "text", possibleValues: "", notes: "If you put a url in this field, an <a> tag will be added, wrapping around the output and pointing to that url."},
  testing_mode: {defaultValue: "no", includeInSettingsBlock: false, includeInConfigFile: false, useQuoteMarksInConfigFile: false, inputType: "yesNo", possibleValues: "", notes: ""},
  last_updated_text: {defaultValue: "", includeInSettingsBlock: false, includeInConfigFile: false, useQuoteMarksInConfigFile: true, inputType: "text", possibleValues: "", notes: ""},
  headline: {defaultValue: "Ai Graphic Headline", includeInSettingsBlock: true, includeInConfigFile: true, useQuoteMarksInConfigFile: true, inputType: "text", possibleValues: "", notes: ""},
  leadin: {defaultValue: "Introductory text here.", includeInSettingsBlock: true, includeInConfigFile: true, useQuoteMarksInConfigFile: true, inputType: "text", possibleValues: "", notes: ""},
  summary: {defaultValue: "", includeInSettingsBlock: false, includeInConfigFile: true, useQuoteMarksInConfigFile: true, inputType: "text", possibleValues: "", notes: "Summary field for Scoop assets"},
  notes: {defaultValue: "Notes: Text goes here.", includeInSettingsBlock: true, includeInConfigFile: true, useQuoteMarksInConfigFile: true, inputType: "text", possibleValues: "", notes: ""},
  sources: {defaultValue: "Source: Name goes here.", includeInSettingsBlock: true, includeInConfigFile: true, useQuoteMarksInConfigFile: true, inputType: "text", possibleValues: "", notes: ""},
  credit: {defaultValue: "By ai2html", includeInSettingsBlock: true, includeInConfigFile: true, useQuoteMarksInConfigFile: true, inputType: "text", possibleValues: "", notes: ""},
  page_template: {defaultValue: "", includeInSettingsBlock: false, includeInConfigFile: false, useQuoteMarksInConfigFile: false, inputType: "text", possibleValues: "", notes: ""},
  publish_system: {defaultValue: "", includeInSettingsBlock: false, includeInConfigFile: false, useQuoteMarksInConfigFile: false, inputType: "text", possibleValues: "", notes: ""},
  environment: {defaultValue: "", includeInSettingsBlock: false, includeInConfigFile: false, useQuoteMarksInConfigFile: false, inputType: "text", possibleValues: "", notes: ""},
  show_in_compatible_apps: {defaultValue: "", includeInSettingsBlock: false, includeInConfigFile: false, useQuoteMarksInConfigFile: true, inputType: "yesNo", possibleValues: "", notes: ""},
  display_for_promotion_only: {defaultValue: "", includeInSettingsBlock: false, includeInConfigFile: false, useQuoteMarksInConfigFile: false, inputType: "trueFalse", possibleValues: "", notes: ""},
  constrain_width_to_text_column: {defaultValue: "", includeInSettingsBlock: false, includeInConfigFile: false, useQuoteMarksInConfigFile: false, inputType: "trueFalse", possibleValues: "", notes: ""},
  scoop_publish_fields: {defaultValue: "", includeInSettingsBlock: false, includeInConfigFile: false, useQuoteMarksInConfigFile: false, inputType: "trueFalse", possibleValues: "", notes: ""},
  scoop_asset_id: {defaultValue: "", includeInSettingsBlock: false, includeInConfigFile: false, useQuoteMarksInConfigFile: false, inputType: "text", possibleValues: "", notes: ""},
  scoop_username: {defaultValue: "", includeInSettingsBlock: false, includeInConfigFile: false, useQuoteMarksInConfigFile: false, inputType: "text", possibleValues: "", notes: ""},
  scoop_slug: {defaultValue: "", includeInSettingsBlock: false, includeInConfigFile: false, useQuoteMarksInConfigFile: false, inputType: "text", possibleValues: "", notes: ""},
  scoop_external_edit_key: {defaultValue: "", includeInSettingsBlock: false, includeInConfigFile: false, useQuoteMarksInConfigFile: false, inputType: "text", possibleValues: "", notes: ""}
};

// End of settings blocks copied from Google Spreadsheet.

var ai2htmlBaseSettings = scriptEnvironment == "nyt" ? nytBaseSettings : defaultBaseSettings;

// ================================================
// Constant data
// ================================================

// html entity substitution
// not used ==> ["\x22","&quot;"], ["\x3C","&lt;"], ["\x3E","&gt;"], ["\x26","&amp;"],
var htmlCharacterCodes = [["\xA0","&nbsp;"], ["\xA1","&iexcl;"], ["\xA2","&cent;"], ["\xA3","&pound;"], ["\xA4","&curren;"], ["\xA5","&yen;"], ["\xA6","&brvbar;"], ["\xA7","&sect;"], ["\xA8","&uml;"], ["\xA9","&copy;"], ["\xAA","&ordf;"], ["\xAB","&laquo;"], ["\xAC","&not;"], ["\xAD","&shy;"], ["\xAE","&reg;"], ["\xAF","&macr;"], ["\xB0","&deg;"], ["\xB1","&plusmn;"], ["\xB2","&sup2;"], ["\xB3","&sup3;"], ["\xB4","&acute;"], ["\xB5","&micro;"], ["\xB6","&para;"], ["\xB7","&middot;"], ["\xB8","&cedil;"], ["\xB9","&sup1;"], ["\xBA","&ordm;"], ["\xBB","&raquo;"], ["\xBC","&frac14;"], ["\xBD","&frac12;"], ["\xBE","&frac34;"], ["\xBF","&iquest;"], ["\xD7","&times;"], ["\xF7","&divide;"], ["\u0192","&fnof;"], ["\u02C6","&circ;"], ["\u02DC","&tilde;"], ["\u2002","&ensp;"], ["\u2003","&emsp;"], ["\u2009","&thinsp;"], ["\u200C","&zwnj;"], ["\u200D","&zwj;"], ["\u200E","&lrm;"], ["\u200F","&rlm;"], ["\u2013","&ndash;"], ["\u2014","&mdash;"], ["\u2018","&lsquo;"], ["\u2019","&rsquo;"], ["\u201A","&sbquo;"], ["\u201C","&ldquo;"], ["\u201D","&rdquo;"], ["\u201E","&bdquo;"], ["\u2020","&dagger;"], ["\u2021","&Dagger;"], ["\u2022","&bull;"], ["\u2026","&hellip;"], ["\u2030","&permil;"], ["\u2032","&prime;"], ["\u2033","&Prime;"], ["\u2039","&lsaquo;"], ["\u203A","&rsaquo;"], ["\u203E","&oline;"], ["\u2044","&frasl;"], ["\u20AC","&euro;"], ["\u2111","&image;"], ["\u2113",""], ["\u2116",""], ["\u2118","&weierp;"], ["\u211C","&real;"], ["\u2122","&trade;"], ["\u2135","&alefsym;"], ["\u2190","&larr;"], ["\u2191","&uarr;"], ["\u2192","&rarr;"], ["\u2193","&darr;"], ["\u2194","&harr;"], ["\u21B5","&crarr;"], ["\u21D0","&lArr;"], ["\u21D1","&uArr;"], ["\u21D2","&rArr;"], ["\u21D3","&dArr;"], ["\u21D4","&hArr;"], ["\u2200","&forall;"], ["\u2202","&part;"], ["\u2203","&exist;"], ["\u2205","&empty;"], ["\u2207","&nabla;"], ["\u2208","&isin;"], ["\u2209","&notin;"], ["\u220B","&ni;"], ["\u220F","&prod;"], ["\u2211","&sum;"], ["\u2212","&minus;"], ["\u2217","&lowast;"], ["\u221A","&radic;"], ["\u221D","&prop;"], ["\u221E","&infin;"], ["\u2220","&ang;"], ["\u2227","&and;"], ["\u2228","&or;"], ["\u2229","&cap;"], ["\u222A","&cup;"], ["\u222B","&int;"], ["\u2234","&there4;"], ["\u223C","&sim;"], ["\u2245","&cong;"], ["\u2248","&asymp;"], ["\u2260","&ne;"], ["\u2261","&equiv;"], ["\u2264","&le;"], ["\u2265","&ge;"], ["\u2282","&sub;"], ["\u2283","&sup;"], ["\u2284","&nsub;"], ["\u2286","&sube;"], ["\u2287","&supe;"], ["\u2295","&oplus;"], ["\u2297","&otimes;"], ["\u22A5","&perp;"], ["\u22C5","&sdot;"], ["\u2308","&lceil;"], ["\u2309","&rceil;"], ["\u230A","&lfloor;"], ["\u230B","&rfloor;"], ["\u2329","&lang;"], ["\u232A","&rang;"], ["\u25CA","&loz;"], ["\u2660","&spades;"], ["\u2663","&clubs;"], ["\u2665","&hearts;"], ["\u2666","&diams;"]];

// Add to the fonts array to make the script work with your own custom fonts.
// To make it easier to add to this array, use the "fonts" worksheet of this Google Spreadsheet:
	// https://docs.google.com/spreadsheets/d/13ESQ9ktfkdzFq78FkWLGaZr2s3lNbv2cN25F2pYf5XM/edit?usp=sharing
	// Make a copy of the spreadsheet for yourself.
	// Modify the settings to taste.
var fonts = [
	{"aifont":"ArialMT","family":"arial,helvetica,sans-serif","weight":"","style":""},
	{"aifont":"Arial-BoldMT","family":"arial,helvetica,sans-serif","weight":"bold","style":""},
	{"aifont":"Arial-ItalicMT","family":"arial,helvetica,sans-serif","weight":"","style":"italic"},
	{"aifont":"Arial-BoldItalicMT","family":"arial,helvetica,sans-serif","weight":"bold","style":"italic"},
	{"aifont":"Georgia","family":"georgia,'times new roman',times,serif","weight":"","style":""},
	{"aifont":"Georgia-Bold","family":"georgia,'times new roman',times,serif","weight":"bold","style":""},
	{"aifont":"Georgia-Italic","family":"georgia,'times new roman',times,serif","weight":"","style":"italic"},
	{"aifont":"Georgia-BoldItalic","family":"georgia,'times new roman',times,serif","weight":"bold","style":"italic"},
	{"aifont":"NYTFranklin-Light","family":"nyt-franklin,arial,helvetica,sans-serif","weight":"300","style":""},
	{"aifont":"NYTFranklin-Medium","family":"nyt-franklin,arial,helvetica,sans-serif","weight":"500","style":""},
	{"aifont":"NYTFranklin-SemiBold","family":"nyt-franklin,arial,helvetica,sans-serif","weight":"600","style":""},
	{"aifont":"NYTFranklinSemiBold-Regular","family":"nyt-franklin,arial,helvetica,sans-serif","weight":"600","style":""},
	{"aifont":"NYTFranklin-Bold","family":"nyt-franklin,arial,helvetica,sans-serif","weight":"700","style":""},
	{"aifont":"NYTFranklin-LightItalic","family":"nyt-franklin,arial,helvetica,sans-serif","weight":"300","style":"italic"},
	{"aifont":"NYTFranklin-MediumItalic","family":"nyt-franklin,arial,helvetica,sans-serif","weight":"500","style":"italic"},
	{"aifont":"NYTFranklin-BoldItalic","family":"nyt-franklin,arial,helvetica,sans-serif","weight":"700","style":"italic"},
	{"aifont":"NYTFranklin-Headline","family":"nyt-franklin,arial,helvetica,sans-serif","weight":"bold","style":""},
	{"aifont":"NYTFranklin-HeadlineItalic","family":"nyt-franklin,arial,helvetica,sans-serif","weight":"bold","style":"italic"},
	{"aifont":"NYTCheltenham-ExtraLight","family":"nyt-cheltenham,georgia,'times new roman',times,serif","weight":"200","style":""},
	{"aifont":"NYTCheltenhamExtLt-Regular","family":"nyt-cheltenham,georgia,'times new roman',times,serif","weight":"200","style":""},
	{"aifont":"NYTCheltenham-Light","family":"nyt-cheltenham,georgia,'times new roman',times,serif","weight":"300","style":""},
	{"aifont":"NYTCheltenhamLt-Regular","family":"nyt-cheltenham,georgia,'times new roman',times,serif","weight":"300","style":""},
	{"aifont":"NYTCheltenham-Book","family":"nyt-cheltenham,georgia,'times new roman',times,serif","weight":"400","style":""},
	{"aifont":"NYTCheltenhamBook-Regular","family":"nyt-cheltenham,georgia,'times new roman',times,serif","weight":"400","style":""},
	{"aifont":"NYTCheltenham-Wide","family":"nyt-cheltenham,georgia,'times new roman',times,serif","weight":"","style":""},
	{"aifont":"NYTCheltenhamMedium-Regular","family":"nyt-cheltenham,georgia,'times new roman',times,serif","weight":"500","style":""},
	{"aifont":"NYTCheltenham-Medium","family":"nyt-cheltenham,georgia,'times new roman',times,serif","weight":"500","style":""},
	{"aifont":"NYTCheltenham-Bold","family":"nyt-cheltenham,georgia,'times new roman',times,serif","weight":"700","style":""},
	{"aifont":"NYTCheltenham-BoldCond","family":"nyt-cheltenham,georgia,'times new roman',times,serif","weight":"bold","style":""},
	{"aifont":"NYTCheltenham-BoldExtraCond","family":"nyt-cheltenham,georgia,'times new roman',times,serif","weight":"bold","style":""},
	{"aifont":"NYTCheltenham-ExtraBold","family":"nyt-cheltenham,georgia,'times new roman',times,serif","weight":"bold","style":""},
	{"aifont":"NYTCheltenham-ExtraLightIt","family":"nyt-cheltenham,georgia,'times new roman',times,serif","weight":"","style":"italic"},
	{"aifont":"NYTCheltenham-ExtraLightItal","family":"nyt-cheltenham,georgia,'times new roman',times,serif","weight":"","style":"italic"},
	{"aifont":"NYTCheltenham-LightItalic","family":"nyt-cheltenham,georgia,'times new roman',times,serif","weight":"","style":"italic"},
	{"aifont":"NYTCheltenham-BookItalic","family":"nyt-cheltenham,georgia,'times new roman',times,serif","weight":"","style":"italic"},
	{"aifont":"NYTCheltenham-WideItalic","family":"nyt-cheltenham,georgia,'times new roman',times,serif","weight":"","style":"italic"},
	{"aifont":"NYTCheltenham-MediumItalic","family":"nyt-cheltenham,georgia,'times new roman',times,serif","weight":"","style":"italic"},
	{"aifont":"NYTCheltenham-BoldItalic","family":"nyt-cheltenham,georgia,'times new roman',times,serif","weight":"700","style":"italic"},
	{"aifont":"NYTCheltenham-ExtraBoldItal","family":"nyt-cheltenham,georgia,'times new roman',times,serif","weight":"bold","style":"italic"},
	{"aifont":"NYTCheltenham-ExtraBoldItalic","family":"nyt-cheltenham,georgia,'times new roman',times,serif","weight":"bold","style":"italic"},
	{"aifont":"NYTKarnakText-Regular","family":"nyt-karnak-display-130124,georgia,'times new roman',times,serif","weight":"400","style":""},
	{"aifont":"NYTKarnakDisplay-Regular","family":"nyt-karnak-display-130124,georgia,'times new roman',times,serif","weight":"400","style":""},
	{"aifont":"NYTStymieLight-Regular","family":"nyt-stymie,arial,helvetica,sans-serif","weight":"300","style":""},
	{"aifont":"NYTStymieMedium-Regular","family":"nyt-stymie,arial,helvetica,sans-serif","weight":"500","style":""},
	{"aifont":"StymieNYT-Light","family":"nyt-stymie,arial,helvetica,sans-serif","weight":"300","style":""},
	{"aifont":"StymieNYT-LightPhoenetic","family":"nyt-stymie,arial,helvetica,sans-serif","weight":"300","style":""},
	{"aifont":"StymieNYT-Lightitalic","family":"nyt-stymie,arial,helvetica,sans-serif","weight":"300","style":"italic"},
	{"aifont":"StymieNYT-Medium","family":"nyt-stymie,arial,helvetica,sans-serif","weight":"500","style":""},
	{"aifont":"StymieNYT-MediumItalic","family":"nyt-stymie,arial,helvetica,sans-serif","weight":"500","style":"italic"},
	{"aifont":"StymieNYT-Bold","family":"nyt-stymie,arial,helvetica,sans-serif","weight":"700","style":""},
	{"aifont":"StymieNYT-BoldItalic","family":"nyt-stymie,arial,helvetica,sans-serif","weight":"700","style":"italic"},
	{"aifont":"StymieNYT-ExtraBold","family":"nyt-stymie,arial,helvetica,sans-serif","weight":"700","style":""},
	{"aifont":"StymieNYT-ExtraBoldText","family":"nyt-stymie,arial,helvetica,sans-serif","weight":"700","style":""},
	{"aifont":"StymieNYT-ExtraBoldTextItal","family":"nyt-stymie,arial,helvetica,sans-serif","weight":"700","style":"italic"},
	{"aifont":"StymieNYTBlack-Regular","family":"nyt-stymie,arial,helvetica,sans-serif","weight":"700","style":""},
	{"aifont":"StymieBT-ExtraBold","family":"nyt-stymie,arial,helvetica,sans-serif","weight":"700","style":""},
	{"aifont":"Stymie-Thin","family":"nyt-stymie,arial,helvetica,sans-serif","weight":"300","style":""},
	{"aifont":"Stymie-UltraLight","family":"nyt-stymie,arial,helvetica,sans-serif","weight":"300","style":""},
	{"aifont":"NYTMagSans-Regular","family":"'nyt-mag-sans',arial,helvetica,sans-serif","weight":"500","style":""},
	{"aifont":"NYTMagSans-Bold","family":"'nyt-mag-sans',arial,helvetica,sans-serif","weight":"700","style":""}
];

var caps = [
	{"ai":"FontCapsOption.NORMALCAPS","html":""},
	{"ai":"FontCapsOption.ALLCAPS","html":"uppercase"},
	{"ai":"FontCapsOption.SMALLCAPS","html":"uppercase"}
];

var align = [
	{"ai":"Justification.LEFT","html":""},
	{"ai":"Justification.RIGHT","html":"right"},
	{"ai":"Justification.CENTER","html":"center"},
	{"ai":"Justification.FULLJUSTIFY","html":"justify"},
	{"ai":"Justification.FULLJUSTIFYLASTLINELEFT","html":"justify"},
	{"ai":"Justification.FULLJUSTIFYLASTLINECENTER","html":"justify"},
	{"ai":"Justification.FULLJUSTIFYLASTLINERIGHT","html":"justify"}
];

var textStyleKeys = [
	"aifont",
	"size",
	"capitalization",
	"color",
	"tracking",
	"leading",
	"spaceBefore",
	"spaceAfter",
	"justification",
	"opacity"
];

var nyt5Breakpoints = [
  { name:"xsmall"    , lowerLimit:   0, upperLimit: 180, artboards:[] },
  { name:"small"     , lowerLimit: 180, upperLimit: 300, artboards:[] },
  { name:"smallplus" , lowerLimit: 300, upperLimit: 460, artboards:[] },
  { name:"submedium" , lowerLimit: 460, upperLimit: 600, artboards:[] },
  { name:"medium"    , lowerLimit: 600, upperLimit: 720, artboards:[] },
  { name:"large"     , lowerLimit: 720, upperLimit: 945, artboards:[] },
  { name:"xlarge"    , lowerLimit: 945, upperLimit:1050, artboards:[] },
  { name:"xxlarge"   , lowerLimit:1050, upperLimit:1600, artboards:[] }
];

// user inputs, settings, etc
var defaultParagraphStyle = {
	aifont: 'NYTFranklin-Medium',
	size: 13,
	leading: 18,
	weight: 500,
	color: getCssColor(0, 0, 0)
};

var nameSpace           = "g-";
var pctPrecision        = 4;
var outputType          = "pct"; // "abs" or "pct"
// value between 0 and 255 lower than which if all three RGB values are below
// then force the RGB to #000 so it is a pure black
var	rgbBlackThreshold  = 36;
var showDebugMessages  = true;

// ================================
// Variable declarations
// ================================

// vars to hold warnings and informational messages at the end
var feedback = [];
var warnings = [];
var errors   = [];

var textFramesToUnhide = [];
var lockedObjects      = [];
var hiddenObjects		   = [];

// Global variables set by main()
var docSettings         = {};
var previewProjectType = "";
var doc, docPath, docIsSaved, pBar;

// ===========================================================
// Run script in AI context, setup for testing in Node context
// ===========================================================

var jsEnvironment = typeof module === "object" && module.exports ? "node" : "ai";
if (jsEnvironment == 'ai') {
	main();
}
if (jsEnvironment == 'node') {
	// export functions for testing
	// TODO: write more tests
  module.exports = {
  	testBoundsIntersection: testBoundsIntersection,
  	trim: trim
  };
}


// =================================
// Main function
// =================================

function main() {
	initScriptEnvironment();
	pBar = new ProgressBar();
	T.start();

	// initialize docSettings
	for (var setting in ai2htmlBaseSettings) {
		docSettings[setting] = ai2htmlBaseSettings[setting].defaultValue;
	}

	if (!app.documents.length) {
		errors.push("No documents are open");

	} else if (!String(app.activeDocument.path)) {
		errors.push('You need to save your Illustrator file before running this script');

	} else if (app.activeDocument.documentColorSpace!="DocumentColorSpace.RGB") {
		errors.push('Convert document color mode to "RGB" before running script. (File>Document Color Mode>RGB Color)' );

	} else {
		doc = app.activeDocument;
		docPath = doc.path + "/";
		docIsSaved = doc.saved;

		try {
			ai2html();
		} catch(e) {
			errors.push("The script threw an error" + (e.message ? ": " + e.message : ''));
		}
		restoreDocumentState();
		pBar.setProgress(1.0);
	}

	// ==========================================
	// Save the AI document (in some cases)
	// ==========================================

	if (docIsSaved) {
		// If document was originally in a saved state, reset the document's
		// saved flag (the document goes to unsaved state during the script,
		// because of unlocking / relocking of objects
		doc.saved = true;
	} else if (errors.length === 0) {
		// Auto-save the document if no errors occurred
		var saveOptions = new IllustratorSaveOptions();
		saveOptions.pdfCompatible = false;
		pBar.setTitle('Saving Illustrator document...');
		T.start();
		doc.saveAs(new File(docPath + doc.name), saveOptions);
		T.stop("Saved document");
		feedback.push("Your Illustrator file was saved.");
	}

	pBar.close();
	T.stop("Total time");

	// =========================================================
	// Show alert box, optionally prompt to generate promo image
	// =========================================================

	if (isTrue(docSettings.show_completion_dialog_box)) {
		// ignoring (obsolete) "create_promo_image" option setting
		var promptForPromo = previewProjectType == "ai2html" && docSettings.write_image_files=="yes";
		var showPromo = showCompletionAlert(promptForPromo);
		if (showPromo) createPromoImage();
	}
} // end main()


// =================================
// ai2html processing function
// =================================

function ai2html() {

	// Unlock all objects
	T.start();
	unlockObjects();
	T.stop('Unlock objects');

	// unhide layers that were hidden so objects inside could be locked
	for (var i = hiddenObjects.length-1; i>=0; i--) {
		hiddenObjects[i].visible = false;
	}

	// ================================================
	// Read .git/config file to get preview slug
	// ================================================

	if (scriptEnvironment=="nyt") {

		var gitConfig = readGitConfigFile(docPath + "../.git/config") || {};
		if (gitConfig.url) {
			docSettings.preview_slug = gitConfig.url.replace( /^[^:]+:/ , "" ).replace( /\.git$/ , "");
		}
	}

	// ================================================
	// Read yml file if it exists to determine what type of project this is
	// ================================================

	if (scriptEnvironment=="nyt") {
		var yaml = readYamlFile(docPath + "../config.yml");
		if (!yaml) {
			previewProjectType = "config.yml is missing";
		} else {
			if (yaml.project_type == 'ai2html') {
				previewProjectType = 'ai2html';
			}
			if (yaml.scoop_slug) {
				docSettings.scoop_slug_from_config_yml = yaml.scoop_slug;
			}
		}
	}

	// ================================================
	// Initialize docSettings object.
	// ================================================

	if (docSettings.project_name === "") {
		docSettings.project_name = doc.name.replace(/(.+)\.[aieps]+$/,"$1").replace(/ /g,"-");
	} else {
		docSettings.project_name = makeKeyword(docSettings.project_name);
	}

	// ================================================
  // assign artboards to their corresponding breakpoints
	// ================================================
  // (can have more than one artboard per breakpoint.)

  var breakpoints = assignBreakpointsToArtboards(nyt5Breakpoints);

	// ================================================
	// add settings text block if one does not exist
	// ================================================

	if (!documentHasSettingsBlock()) {
		createSettingsBlock();
		if (docSettings.ai2html_environment=="nyt") {
			feedback.push("A settings text block was created to the left of all your artboards. Fill out the settings to link your project to the Scoop asset.");
			return; // Exit the script
		} else {
			feedback.push("A settings text block was created to the left of all your artboards. You can use it to customize your output.");
		}
	}

	// ================================================
	// grab custom settings, html, css, js and text blocks
	// ================================================

	var customCss      = "",
		customJs         = "",
		customHtml       = "",
		customCssBlocks  = 0,
		customHtmlBlocks = 0,
		customJsBlocks   = 0;

	for (var tfNumber=0; tfNumber < doc.textFrames.length; tfNumber++) {
		var thisFrame = doc.textFrames[tfNumber];
		if (thisFrame.lines.length < 2) {
			continue;
		}
		var firstLine = thisFrame.lines[0].contents;
		if (firstLine == "ai2html-css") {
			hideTextFrame(thisFrame);
			customCssBlocks += 1;
			customCss += "\t\t/* Custom CSS block " + customCssBlocks + " */\r";
			for (var p=1; p < thisFrame.paragraphs.length; p++) {
				try {
					customCss += "\t\t" + cleanText(thisFrame.paragraphs[p].contents) + "\r";
				} catch(e) {}
			}
		}
		if (firstLine == "ai2html-html") {
			hideTextFrame(thisFrame);
			customHtmlBlocks += 1;
			customHtml += "\r\t<!-- Custom HTML block " + customHtmlBlocks + " -->\r";
			for (var p=1; p < thisFrame.paragraphs.length; p++) {
				try {
					customHtml += "\t" + cleanText(thisFrame.paragraphs[p].contents) + "\r";
				} catch(e) {}
			}
		}
		if (firstLine == "ai2html-js") {
			hideTextFrame(thisFrame);
			customJsBlocks += 1;
			customJs += "\r\t<!-- Custom JS block " + customJsBlocks + " -->\r";
			for (var p=1; p < thisFrame.paragraphs.length; p++) {
				try {
					customJs += "\t" + cleanText(thisFrame.paragraphs[p].contents) + "\r";
				} catch(e) {}
			}
		}
		if (firstLine == "ai2html-settings" || firstLine == "ai2html-text") {
			hideTextFrame(thisFrame);
			parseSettingsTextBlock(thisFrame, docSettings);
		}
	}

	var imageExtension = ".png";
	if (docSettings.image_format.length > 0) {
		imageExtension = "." + docSettings.image_format[0].substring(0,3);
	}

	// ================================================
	// validate settings
	// ================================================

	if (docSettings.max_width !== "" && docSettings.ai2html_environment ==="nyt") {
		var max_width_is_valid = false;
		for (var bpNumber = 0; bpNumber < nyt5Breakpoints.length; bpNumber++) {
			if (docSettings.max_width == nyt5Breakpoints[bpNumber].upperLimit.toString()) {
				max_width_is_valid = true;
			}
		}
		if (!max_width_is_valid) {
			warnings.push('The max_width setting of "' + docSettings.max_width + '" is not a valid breakpoint and will create an error when you "preview publish."');
		}
	}

	// ================================================
	// reset the output path and extension if the previewProjectType is ai2html and fix other path issues
	// ================================================

	if (previewProjectType=="ai2html") {
		docSettings.html_output_path      = "/../public/";
		docSettings.html_output_extension = ".html";
		docSettings.image_output_path     = "_assets/";
	}
	docSettings.preview_image_path = "_assets/";

	if (docSettings.image_source_path === null) {
		// fall back to image output path
		docSettings.image_source_path = docSettings.image_output_path;
	}

	// ================================================
	// check for invalid NYT Preview environment
	// ================================================

  if (docSettings.ai2html_environment=="nyt") {
		if (previewProjectType=="config.yml is missing" ||
				(previewProjectType=="ai2html" && !folderExists(docPath + "../public/")) ||
				(previewProjectType!="ai2html" && !folderExists(docPath + "../src/"))) {
			errors.push("Make sure your Illustrator file is inside the \u201Cai\u201D folder of a Preview project.");
			errors.push("If the Illustrator file is in the correct folder, your Preview project may be missing a config.yml file or a \u201Cpublic\u201D or a \u201Csrc\u201D folder.");
			errors.push("If this is an ai2html project, it is probably easier to just create a new ai2html Preview project and move this Illustrator file into the \u201Cai\u201D folder inside the project.");
			return;
		}
  }

	var uniqueArtboardWidths = [];
	if (docSettings.include_resizer_widths == "yes") {
		// measure breakpoints based on artboard widths
		for (var abNumber = 0; abNumber < doc.artboards.length; abNumber++) {
			var ab = doc.artboards[abNumber];
			if (!artboardIsUsable(ab)) continue;
			var abRect = doc.artboards[abNumber].artboardRect,
				abW = Math.round(abRect[2]-abRect[0]),
				customMinWidth = doc.artboards[abNumber].name.split(':')[1];
			if (customMinWidth) abW = Math.round(+customMinWidth);
			if (uniqueArtboardWidths.indexOf(abW) < 0) uniqueArtboardWidths.push(abW);
		}
		uniqueArtboardWidths.sort(function(a,b){return a-b;});
	}


	// ================================================
	// Generate HTML, CSS and images for contents of each artboard
	// ================================================

	var artboardHtml = "";
	var artboardCss = "";

	forEachArtboard(function(activeArtboard, abNumber) {
		T.start();

		doc.artboards.setActiveArtboardIndex(abNumber);
		// doc.selectObjectsOnActiveArtboard();

		docSettings.docName     =  makeKeyword(docSettings.project_name);
		var artboardName        =  makeKeyword(activeArtboard.name.replace( /^(.+):\d+$/ , "$1"));
		// var docArtboardName     =  makeKeyword(docSettings.project_name) + "-" + artboardName + "-" + abNumber;
		var docArtboardName     =  docSettings.docName + "-" + artboardName;
		var activeArtboardRect  =  activeArtboard.artboardRect;
		var abX                 =  activeArtboardRect[0];
		var abY                 = -activeArtboardRect[1];
		var abW                 =  Math.round(activeArtboardRect[2]-abX);
		var abH                 = -activeArtboardRect[3]-abY;
		var artboardAspectRatio =  abH/abW;

		pBar.setTitle(docArtboardName + ': Starting to generate HTML...');
		pBar.setProgress(abNumber/(doc.artboards.length));

		var html = [];
		var numHtmlStrands   = 12;
		for (var i=0;i<numHtmlStrands;i++) {html[i] = "";}


		html[1] += "\r\t<!-- Artboard: " + artboardName + " -->\r";

    /*
		var showClass = "";

		for (var bpNumber = 0; bpNumber < nyt5Breakpoints.length; bpNumber++) {
			var nyt5Breakpoint = nyt5Breakpoints[bpNumber];
			for (var bpArtboardNumber = 0; bpArtboardNumber < nyt5Breakpoint.artboards.length; bpArtboardNumber++) {
				var bpArtboard = nyt5Breakpoint.artboards[bpArtboardNumber];
				if (abNumber==bpArtboard) {
					showClass += (showClass.length>0) ? " ":"";
					showClass += "g-show-" + nyt5Breakpoint.name;
				}
			}
		}

		if (docSettings.include_resizer_classes=="no") {
			showClass = "";
		}
    */

    var showClasses = "";
    if (docSettings.include_resizer_classes != "no") {
      showClasses = findShowClassesByArtboardId(abNumber, breakpoints);
    }

		// TODO: refactor this stuff
		//
		html[1] += "\t<div id='"+nameSpace+docArtboardName+"' class='"+nameSpace+"artboard "+nameSpace+"artboard-v3 "+showClasses+"'";
		if (docSettings.include_resizer_widths == "yes") {
			// add data-min/max-width attributes
			// find breakpoints
			for (var bpIndex = 1; bpIndex < uniqueArtboardWidths.length; bpIndex++) {
				if (abW < uniqueArtboardWidths[bpIndex]) break;
			}
			html[1] += " data-min-width='"+uniqueArtboardWidths[bpIndex-1]+"'";
			if (bpIndex < uniqueArtboardWidths.length) {
				html[1] += " data-max-width='"+(uniqueArtboardWidths[bpIndex]-1)+"'";
			}
		}
		html[1] += ">\r";
		html[1] += "\t\t<style type='text/css' media='screen,print'>\r";
		html[1] += "\t\t\t#"+nameSpace+docArtboardName+"{\r";
		html[1] += "\t\t\t\tposition:relative;\r";
		html[1] += "\t\t\t\toverflow:hidden;\r";
		if (docSettings.responsiveness=="fixed") {
			html[1] += "\t\t\t\twidth:"  + Math.round(abW) + "px;\r";
		}
		// if (docSettings.max_width!="") {
		// 	html[1] += "\t\t\t\tmax-width:"  + Math.round(docSettings.max_width) + "px;\r";
		// }
		html[1] += "\t\t\t}\r";
		html[1] += "\t\t\t."+nameSpace+"aiAbs{\r";
		html[1] += "\t\t\t\tposition:absolute;\r";
		html[1] += "\t\t\t}\r";
		html[1] += "\t\t\t."+nameSpace+"aiImg{\r";
		html[1] += "\t\t\t\tdisplay:block;\r";
		html[1] += "\t\t\t\twidth:100% !important;\r";
		html[1] += "\t\t\t}\r";

		// default <p> style
		html[1] += "\t\t\t#"+nameSpace+docArtboardName+" p {\r";
		if (docSettings.testing_mode=="yes") {
			html[1] += "\t\t\t\tcolor: rgba(209, 0, 0, 0.5) !important;\r";
		}
		html[1] += "\t\t\t\tmargin:0;";
		html[1] += generateStyleCss(defaultParagraphStyle);
		html[1] += "\t\t\t}\r";

		html[4] += "\t\t</style>\r";
		html[4] += "\t\t<div id='"+nameSpace+docArtboardName+"-graphic'>\r";

		if (outputType=="abs") {
			// this option appears to not really be needed
			html[5] += "\t\t\t<img id='" +nameSpace+"ai"+abNumber+"-0'\r";
			html[5] += "\t\t\t\tclass='" +nameSpace+"aiAbs "+nameSpace+"aiImg'\r";
			if (docSettings.ai2html_environment=="nyt") {
				html[5] += "\t\t\t\tsrc='"   + docSettings.preview_image_path + docArtboardName + imageExtension + "'\r";
			} else {
				html[5] += "\t\t\t\tsrc='"   + docSettings.image_source_path + docArtboardName + imageExtension + "'\r";
			}
			html[5] += "\t\t\t\twidth="  + Math.round(abW) + "\r";
			html[5] += "\t\t\t\theight=" + Math.round(abH) + "\r";
			html[5] += "\t\t\t\t/>\r";
		} else if (outputType=="pct") {
			// this is the default option which seems to work with both fixed and dynamic responsiveness
			html[5] += "\t\t\t<img id='" +nameSpace+"ai"+abNumber+"-0'\r";
			html[5] += "\t\t\t\tclass='" +nameSpace+"aiImg'\r";
			// html[5] += "\t\t\t\tstyle='width:100% !important;'\r";
			if (docSettings.use_lazy_loader=="no") {
				if (docSettings.ai2html_environment=="nyt") {
					html[5] += "\t\t\t\tsrc='"   + docSettings.preview_image_path + docArtboardName + imageExtension + "'\r";
				} else {
					html[5] += "\t\t\t\tsrc='"   + docSettings.image_source_path + docArtboardName + imageExtension + "'\r";
				}
			} else {
				html[5] += "\t\t\t\tsrc='data:image/gif;base64,R0lGODlhCgAKAIAAAB8fHwAAACH5BAEAAAAALAAAAAAKAAoAAAIIhI+py+0PYysAOw=='\r"; // dummy image to hold space while image loads
				if (docSettings.ai2html_environment=="nyt") {
					html[5] += "\t\t\t\tdata-src='"   + docSettings.preview_image_path + docArtboardName + imageExtension + "'\r";
				} else {
					html[5] += "\t\t\t\tdata-src='"   + docSettings.image_source_path + docArtboardName + imageExtension + "'\r";
				}
				html[5] += "\t\t\t\tdata-height-multiplier='" + round(artboardAspectRatio,4) + "'\r";
			}
			html[5] += "\t\t\t\t/>\r";
		}

		html[8]  += "\t\t</div>\r"; // closing the nameSpace+docArtboardName div
		html[11] += "\t</div>\r";


		// ========================
		// Convert text objects
		// ========================
		T.start();
		pBar.setTitle(docArtboardName + ': Generating text...');
		var textFrames  = getTextFramesByArtboard(activeArtboard);
		var pClasses = [];
		var charClasses = [];

		forEach(textFrames, function(thisFrame, i) {
			var range, rangeData, frameId;

			// Generate a <div> element for each text frame, including CSS styles
			if (thisFrame.name !== "") {
				frameId = makeKeyword(thisFrame.name);
			} else {
				frameId = nameSpace + "ai" + abNumber + "-" + (i + 1);
			}
			html[6] += '\t\t\t<div id="' + frameId + '" ' +
					getTextPositionCss(thisFrame, activeArtboardRect) + '>\r';

			// Generate a <p> tag for each paragraph or line of text
			// The following code runs with either paragraphs or lines
			// Using lines should prevent inconsistent word wrapping between AI and HTML
			//
			for (var k=0, n=thisFrame.paragraphs.length; k<n; k++) {
				range = thisFrame.paragraphs[k];
				rangeData = convertParagraph(range, pClasses, charClasses);
				// Warning: after calling convertParagraph(), a paragraph object may
				// become unusable; simply referencing thisFrame.paragraphs[k] may throw an error
				// (unclear why. sample file: 0125 web DISTRICTmap.ai)
				html[6] += "\t\t\t\t<p class='" + rangeData.classname + "'>" + rangeData.html + "</p>\r";

			}
			html[6] += "\t\t\t</div>\r";
		});

		// Generate CSS class definitions
		forEach(pClasses.concat(charClasses), function(classObj) {
			html[2] += "\t\t\t#" + nameSpace + docArtboardName + " ." +
					classObj.classname + " {" + classObj.css + "\t\t\t}\r";
		});

		html[2] += '\t\t\t.g-aiPtransformed p { white-space: nowrap; }\r';

		T.stop("Text generation");

    // ==========================
    // Generate artboard image(s)
    // ==========================

		T.start();
		// Hide text frames in preparation for image generation
		for (var i=0;i<textFrames.length;i++) {
			hideTextFrame(textFrames[i]);
		}

		// Unhide text now if in testing mode
		if (docSettings.testing_mode=="yes") {
			for (var i=0;i<textFrames.length;i++) {
				textFrames[i].hidden = false;
			}
		}

		if (docSettings.write_image_files=="yes") {
			pBar.setTitle(docArtboardName + ': Writing image...');

			var imageDestinationFolder = docPath + docSettings.html_output_path + docSettings.image_output_path;
			checkForOutputFolder(imageDestinationFolder, "image_output_path");
			var imageDestination = imageDestinationFolder + docArtboardName;

			// if in svg export, hide path elements outside of the current artboard
			if (contains(docSettings.image_format, 'svg')) {
				// save refs to elements we are hiding
				var hiddenItemsOutsideArtboard = hideElementsOutsideArtboardRect(activeArtboardRect);
			}

			exportImageFiles(imageDestination,abW,abH,docSettings.image_format,1.0,docSettings.use_2x_images_if_possible);

			if (contains(docSettings.image_format, 'svg')) {
        // unhide non-text elements hidden before export
        forEach(hiddenItemsOutsideArtboard, function(item) {item.hidden = false;});
			}
		}

		// unhide text now if NOT in testing mode
		if (docSettings.testing_mode!="yes") {
			for (var i=0;i<textFrames.length;i++) {
				textFrames[i].hidden = false;
			}
		}
		T.stop("Image generation");


		//=====================================
		// output html file here if doing a file for every artboard
		//=====================================

    // Concatenate html fragments
    artboardHtml += html.join('');

		if (docSettings.output=="multiple-files") {
			var content = getPageContent(artboardHtml, customHtml, customJs, customCss);
			generateHtml(content, docArtboardName, docSettings);
			artboardHtml = "";
		}
		T.stop("Total for artboard " + abNumber);

	}); // end artboard loop

	//=====================================
	// output html file here if doing one file for all artboards
	//=====================================

	if (docSettings.output=="one-file") {
		var content = getPageContent(artboardHtml, customHtml, customJs, customCss);
		generateHtml(content, docSettings.project_name, docSettings);
	}

	//=====================================
	// write configuration file with graphic metadata
	//=====================================

	if ((docSettings.ai2html_environment=="nyt" && previewProjectType=="ai2html") ||
			(docSettings.ai2html_environment!="nyt" && docSettings.create_config_file)) {
    var yamlPath = docPath + docSettings.config_file_path,
        yamlStr = generateYmlFileContent(breakpoints, docSettings);
    checkForOutputFolder(yamlPath.replace(/[^\/]+$/, ""), "configFileFolder");
    saveTextFile(yamlPath, yamlStr);
	}


	if (docSettings.image_format.length === 0) {
		warnings.push("No images output because no image formats were specified.");
	}
	if (customCssBlocks==1)  { feedback.push(customCssBlocks  + " custom CSS block was added."); }
	if (customCssBlocks>1)   { feedback.push(customCssBlocks  + " custom CSS blocks were added."); }
	if (customHtmlBlocks==1) { feedback.push(customHtmlBlocks + " custom HTML block was added."); }
	if (customHtmlBlocks>1)  { feedback.push(customHtmlBlocks + " custom HTML blocks were added."); }
	if (customJsBlocks==1)   { feedback.push(customJsBlocks   + " custom JS block was added."); }
	if (customJsBlocks>1)    { feedback.push(customJsBlocks   + " custom JS blocks were added."); }

} // end ai2html()


// =================================
// utility functions
// =================================

// Remove whitespace from beginning and end of a string
function trim(s) {
	return s.replace(/^[\s\uFEFF\xA0]+|[\s\uFEFF\xA0]+$/g, '');
}

// http://samuelmullen.com/2012/03/left-pad-zeroes-in-javascript/
function zeroPad(value, padding) {
	var zeroes = "0";
	for (var i = 0; i < padding; i++) { zeroes += "0"; }
	return (zeroes + value).slice(padding * -1);
}

function forEach(arr, cb) {
	for (var i=0, n=arr.length; i<n; i++) {
		cb(arr[i], i);
	}
}

function contains(arr, val) {
  for (var i=0, n=arr.length; i<n; i++) {
    if (arr[i] === val) return true;
  }
  return false;
}

// return elements in array "a" but not in array "b"
function arraySubtract(a, b) {
  var diff = [],
      alen = a.length,
      blen = b.length,
      i, j;
  for (i=0; i<alen; i++) {
    diff.push(a[i]);
    for (j=0; j<blen; j++) {
      if (a[i] === b[j]) {
        diff.pop();
        break;
      }
    }
  }
  return diff;
}

// multiple key sorting function based on https://github.com/Teun/thenBy.js
// first by length of name, then by population, then by ID
// data.sort(
//     firstBy(function (v1, v2) { return v1.name.length - v2.name.length; })
//     .thenBy(function (v1, v2) { return v1.population - v2.population; })
//     .thenBy(function (v1, v2) { return v1.id - v2.id; });
// );
function firstBy(f1, f2) {
	var compare = f2 ? function(a, b) {return f1(a, b) || f2(a, b);} : f1;
	compare.thenBy = function(f) {return firstBy(compare, f);};
	return compare;
}

function makeKeyword(text) {
	return text.replace( /[^A-Za-z0-9_\-]/g , "_" );
}

function cleanText(text) {
	for (var i=0; i < htmlCharacterCodes.length; i++) {
		var charCode = htmlCharacterCodes[i];
		if (text.indexOf(charCode[0]) > -1) {
			text = text.replace(new RegExp(charCode[0],'g'), charCode[1]);
		}
	}
	return text;
}

function straightenCurlyQuotesInsideAngleBrackets(text) {
	// thanks to jashkenas
	var tagFinder = /<[^\n]+?>/g;
	var quoteFinder = /[\u201C‘’\u201D]([^\n]*?)[\u201C‘’\u201D]/g;
	return text.replace(tagFinder, function(tag){
		return tag.replace( /[\u201C\u201D]/g , '"' ).replace( /[‘’]/g , "'" );
	});
}

function round(number, precision) {
	var d = Math.pow(10, precision || 0);
	return Math.round(number * d) / d;
}

function folderExists(path) {
	return new Folder(path).exists;
}

// TODO: value could change during program execution -- does this matter?
function getDateTimeStamp() {
	var d             = new Date();
	var currYear      = d.getFullYear();
	var currDate      = zeroPad(d.getDate(),2);
	var currMonth     = zeroPad(d.getMonth() + 1,2); //Months are zero based
	var currHour      = zeroPad(d.getHours(),2);
	var currMin       = zeroPad(d.getMinutes(),2);
  return currYear + "-" + currMonth + "-" + currDate + " - " + currHour + ":" + currMin;
}

function readYamlFile(path) {
	var file = new File(path);
	var o = null;
	var parts;
	if (file.exists) {
		o = {};
		file.open("r");
		while(!file.eof) {
			parts = file.readln().split(':');
			if (parts.length > 1) {
				o[trim(parts[0])] = trim(parts[1]);
			}
		}
		file.close();
	}
	return o;
}

function readGitConfigFile(path) {
	var file = new File(path);
	var o = null;
	var parts;
	if (file.exists) {
		o = {};
		file.open("r");
		while(!file.eof) {
			parts = file.readln().split("=");
			if (parts.length > 1) {
				o[trim(parts[0])] = trim(parts[1]);
			}
		}
		file.close();
	}
	return o;
}

function getRGBColor(r,g,b) {
  var col = new RGBColor();
  col.red = r || 0;
  col.green = g || 0;
  col.blue = b || 0;
  return col;
}

function readTextFile(path) {
  var outputText = "";
  var file = new File(path);
  if (file.exists) {
    file.open("r");
    while (!file.eof) {
      outputText += file.readln() + "\n";
    }
    file.close();
  } else {
    warnings.push(path + " could not be found.");
  }
  return outputText;
}

function saveTextFile(dest, contents) {
  var configFile = new File(dest);
  configFile.open("w", "TEXT", "TEXT");
  configFile.lineFeed = "Unix";
  configFile.encoding = "UTF-8";
  configFile.writeln(contents);
  configFile.close();
}

/*

function testBoundsIntersection(a, b) {
  var visibleLeft   =  a[0];
  var visibleTop    = -a[1];
  var visibleRight  =  a[2];
  var visibleBottom = -a[3];
  var abLeft   =  b[0];
  var abTop    = -b[1];
  var abRight  =  b[2];
  var abBottom = -b[3];
  // TODO: simplify -- don't need so many comparisons
  // note: in ExtendScript, it seems that && and || have same priority (!)
  var inX = (visibleLeft >= abLeft && visibleLeft <= abRight) ||
    (visibleRight >= abLeft && visibleRight <= abRight) ||
    (visibleLeft <= abLeft && visibleRight >= abRight);
  var inY = (visibleTop >= abTop && visibleTop <= abBottom) ||
    (visibleBottom >= abTop && visibleBottom <= abBottom) ||
    (visibleTop <= abTop && visibleBottom >= abBottom);
  return inX && inY;
}
*/

// a, b: coordinate arrays, as from <PathItem>.geometricBounds
function testBoundsIntersection(a, b) {
  return a[2] >= b[0] && b[2] >= a[0] && a[3] <= b[1] && b[3] <= a[1];
}

function getArtboardPos(rect) {
	var x = rect[0],
			y = -rect[1],
			w = Math.round(rect[2] - x),
			h = -rect[3] - y;
	return {
		x: x,
		y: y,
		width: w,
		height: h
	};
}

function objectIsHidden(obj) {
	var hidden = false;
	while (!hidden && obj && obj.typename != "Document"){
		if (obj.typename == "Layer") {
			hidden = !obj.visible;
		} else {
			hidden = obj.hidden;
		}
		obj = obj.parent;
	}
	return hidden;
}

function ProgressBar() {
  var win = new Window("palette", "Ai2html progress", [150, 150, 600, 260]);
  win.pnl = win.add("panel", [10, 10, 440, 100], "Progress");
  win.pnl.progBar      = win.pnl.add("progressbar", [20, 35, 410, 60], 0, 100);
  win.pnl.progBarLabel = win.pnl.add("statictext", [20, 20, 320, 35], "0%");
  win.show();

	function getProgress() {
	  return win.pnl.progBar.value/win.pnl.progBar.maxvalue;
	}

	this.setProgress = function(progress) {
	  var max = win.pnl.progBar.maxvalue;
	  // progress is always 0.0 to 1.0
	  var pct = progress * max;
	  win.pnl.progBar.value = pct;
	  win.pnl.progBarLabel.text = Math.round(pct) + "%";
	  win.update();
	};

	this.setTitle = function(title) {
	  win.pnl.text = title;
	  win.update();
	};

	this.increment = function(amount) {
	  amount = amount || 0.01;
	  this.setProgress(getProgress() + amount);
	  win.update();
	};

	this.close = function() {
		win.update();
		win.close();
	};
}

function testSimilarBounds(a, b, maxOffs) {
  if (maxOffs >= 0 === false) maxOffs = 1;
  for (var i=0; i<4; i++) {
    if (Math.abs(a[i] - b[i]) > maxOffs) return false;
  }
  return true;
}

// =====================================
// ai2html utility functions
// =====================================

function message(msg) {
	for (var i=1; i<arguments.length; i++) {
		msg += ' ' + arguments[i];
	}
	if (showDebugMessages) feedback.push(msg);
}

// accept inconsistent true/yes values in settings
function isTrue(val) {
	return val == "true" || val == "yes";
}

function isFalse(val) {
	return val == "false" || val == "no";
}

function unlockObjectsInside(parent) {
  var i, n, obj;
  // unlock locked clipping paths (so masked-out text can be detected later)
  for (i=0, n=parent.pathItems.length; i<n; i++) {
    obj = parent.pathItems[i];
    if (obj.locked === true && obj.clipping === true) {
      obj.locked = false;
      lockedObjects.push(obj);
      break;
    }
  }

  // TODO: ask Archie why bother to unlock text objects
  for (i=0, n=parent.textFrames.length; i<n; i++) {
    obj = parent.textFrames[i];
    // this line is producing the MRAP error!!!
    if (obj.locked === true) {
      obj.locked = false;
      lockedObjects.push(obj);
    }
  }
}

function unlockObjects() {
  forEachLayer(function(lyr) {
    if (lyr.locked === true) {
      lyr.locked = false;
      lockedObjects.push(lyr);
    }
    // TODO: ask Archie why unhide layers
    if (lyr.visible === false) {
      lyr.visible = true;
      hiddenObjects.push(lyr);
    }
    unlockObjectsInside(lyr);
  });

  for (var i=0, n=doc.groupItems.length; i<n; i++) {
    var group = doc.groupItems[i];
    if (group.locked) {
      group.locked = false;
      lockedObjects.push(group);
    }
    unlockObjectsInside(group);
  };
}


function forEachLayer(cb, parent) {
  var layers = parent ? parent.layers : doc.layers;
  for (var i=0, n=layers.length; i<n; i++) {
    cb(layers[i]);
    forEachLayer(cb, layers[i]);
  }
}

// ===========================
// ai2html program state and settings
// ===========================


// Add polyfills, etc.
function initScriptEnvironment() {
  // TODO: don't setup dev environment for production use
  initDevEnvironment();

  // Adding [].indexOf to Illustrator JavaScript
  if (!Array.prototype.indexOf) {
      Array.prototype.indexOf = function(elt /*, from*/) {
          var len = this.length;
          var from = Number(arguments[1]) || 0;
          from = (from < 0) ? Math.ceil(from) : Math.floor(from);
          if (from < 0) from += len;
          for (; from < len; from++) {
              if (from in this && this[from] === elt) return from;
          }
          return -1;
     };
  }
}

function initDevEnvironment() {
  // include JSON for debugging objects
  // @include "lib/json2.js"

  // Performance timing using T.start() and T.stop("message")
  T = {
    stack: [],
    start: function() {
      T.stack.push(+new Date());
    },
    stop: function(note) {
      var msg = (+new Date() - T.stack.pop()) + 'ms';
      if (note) msg += " - " + note;
      message(msg);
    }
  };
}

function documentHasSettingsBlock() {
	var found = false;
	forEach(doc.textFrames, function(frame, i) {
		if (frame.lines.length > 1 && frame.lines[0].contents == 'ai2html-settings') {
			found = true;
		}
	});
	return found;
}

function createSettingsBlock() {
	var bounds			= getArtboardBounds();
	var fontSize 		= 15;
	var leading     = 22;
	var extraLines  = 6;
	var width       = 400;
	var left        = bounds[0] - width - 50;
	var top 				= bounds[1];
	var settingsLines = ["ai2html-settings"];
	var layer, rect, textArea, height;

	for (var name in ai2htmlBaseSettings) {
		if (ai2htmlBaseSettings[name].includeInSettingsBlock) {
			settingsLines.push(name + ": " + ai2htmlBaseSettings[name].defaultValue);
		}
	}

	try {
		layer = doc.layers.getByName("ai2html-settings");
	} catch(e) {
		layer = doc.layers.add();
		layer.zOrder(ZOrderMethod.BRINGTOFRONT);
		layer.name  = "ai2html-settings";
	}

	height = leading * (settingsLines.length + extraLines);
	rect = layer.pathItems.rectangle(top, left, width, height);
	textArea = layer.textFrames.areaText(rect);
	textArea.textRange.autoLeading = false;
	textArea.textRange.characterAttributes.leading = leading;
	textArea.textRange.characterAttributes.size = fontSize;
	textArea.contents = settingsLines.join('\n');
}


// Add ai2html settings contained in a text frame to the document settings object
function parseSettingsTextBlock(frame, docSettings) {
  try {
    for (var p=1; p<frame.paragraphs.length; p++) {
      var thisParagraph    = frame.paragraphs[p].contents;
      var hashKey          = thisParagraph.replace( /^[ \t]*([^ \t:]*)[ \t]*:(.*)$/ , "$1" );
      var hashValue        = thisParagraph.replace( /^[ \t]*([^ \t:]*)[ \t]*:(.*)$/ , "$2" );
      hashKey              = trim(hashKey);
      hashValue            = trim(hashValue);
      hashValue            = straightenCurlyQuotesInsideAngleBrackets(hashValue);

      // replace values from old versions of script with current values
      if (hashKey=="output" && hashValue=="one-file-for-all-artboards") { hashValue="one-file"; }
      if (hashKey=="output" && hashValue=="one-file-per-artboard")      { hashValue="multiple-files"; }
      if (hashKey=="output" && hashValue=="preview-one-file")           { hashValue="one-file"; }
      if (hashKey=="output" && hashValue=="preview-multiple-files")     { hashValue="multiple-files"; }
      // handle stuff that goes in config file and other exceptions, like array values
      if ((hashKey in ai2htmlBaseSettings) && ai2htmlBaseSettings[hashKey].includeInConfigFile) {
        hashValue = (hashValue.replace( /(["])/g , '\\$1' )); // add stuff to ["] for chars that need to be esc in yml file
      } else {
        if ((hashKey in ai2htmlBaseSettings) && ai2htmlBaseSettings[hashKey].inputType=="array") {
          hashValue = hashValue.replace( /[\s,]+/g , ',' );
          if (hashValue.length === 0) {
            hashValue = []; // have to do this because .split always returns an array of length at least 1 even if it's splitting an empty string
          } else {
            hashValue = hashValue.split(",");
          }
        }
      }
      docSettings[hashKey] = hashValue;
    }
  } catch(e) {
    warnings.push("Error parsing settings block: " + e.message);
  }
}


// Show alert or prompt; return true if promo image should be generated
function showCompletionAlert(showPrompt) {
  var alertText = "";
  var alertHed = "";
  var retn = false;
  var rule = "\n================\n";

  if (scriptEnvironment == "nyt") {
    alertHed = "Actually, that\u2019s not half bad :)"; // &rsquo;
  } else {
    alertHed = "Nice work!";
  }

  if (errors.length > 0) {
    alertHed = "The Script Was Unable to Finish";
    if (errors.length == 1) {
      alertText += "\rError" + rule;
    } else {
      alertText += "\rErrors" + rule;
    }
    for (var e = 0; e < errors.length; e++) {
      alertText += "\u2022 " + errors[e] + "\r"; // \u2022 is •
    }
  }
  if (warnings.length > 0) {
    if (warnings.length == 1) {
      alertText += "\rWarning" + rule;
    } else {
      alertText += "\rWarnings" + rule;
    }
    for (var w = 0; w < warnings.length; w++) {
      alertText += "\u2022 " + warnings[w] + "\r";
    }
  }
  if (feedback.length > 0) {
    alertText += "\rInformation" + rule;
    for (var f = 0; f < feedback.length; f++) {
      alertText += "\u2022 " + feedback[f] + "\r";
    }
  }
  alertText += "\n";

  if (showPrompt) {
    alertText += rule + "Generate promo image?";
    retn = confirm(alertHed  + alertText, true); // true: "No" is default
  } else {
    alertText += rule + "ai2html-nyt5 v" + scriptVersion;
    alert(alertHed + alertText);
  }
  return retn;
}

function restoreDocumentState() {
  // Unhide stuff that was hidden during processing
  for (var i = 0; i < textFramesToUnhide.length; i++) {
    var currentFrameToUnhide = textFramesToUnhide[i];
    currentFrameToUnhide.hidden = false;
  }

  // Unhide layers so objects inside can be unlocked
  for (var i = hiddenObjects.length-1; i>=0; i--) {
    hiddenObjects[i].visible = true;
  }

  // Restore locked objects
  for (var i = lockedObjects.length-1; i>=0; i--) {
    lockedObjects[i].locked = true;
  }

  // Restore hidden layers
  for (var i = hiddenObjects.length-1; i>=0; i--) {
    hiddenObjects[i].visible = false;
  }
}


// ==============================
// ai2html text functions
// ==============================

function textIsTransformed(textFrame) {
  return !(textFrame.matrix.mValueA == 1 &&
    textFrame.matrix.mValueB === 0 &&
    textFrame.matrix.mValueC === 0 &&
    textFrame.matrix.mValueD === 1);
    // || textFrame.textRange.characterAttributes.horizontalScale != 100
    // || textFrame.textRange.characterAttributes.verticalScale != 100;
}

function hideTextFrame(textFrame) {
  textFramesToUnhide.push(textFrame);
  textFrame.hidden = true;
}


// Parse an AI CharacterAttributes object
function getCharStyle(c) {
  var fill = c.fillColor;
  var filltype = fill.typename;
  var caps = String(c.capitalization);
  var o = {
    aifont: c.textFont.name,
    size: Math.round(c.size),
    capitalization: caps == 'FontCapsOption.NORMALCAPS' ? '' : caps,
    tracking: c.tracking
  };
  var r, g, b;

  if (filltype == 'RGBColor') {
    r = fill.red;
    g = fill.green;
    b = fill.blue;
    if (r < rgbBlackThreshold && g < rgbBlackThreshold && b < rgbBlackThreshold) {
      r = g = b = 0;
    }
  } else if (filltype == 'GrayColor') {
    r = g = b = (100 - fill.gray) / 100 * 255;
  } else if (filltype == 'NoColor') {
    g = 255;
    r = b = 0;
    // warnings are processed later, after ranges of same-style chars are identified
    o.warning = "Some text has no fill. Please fill it with an RGB color. It has been filled with green.";
  } else {
    r = g = b = 0;
    o.warning = "Some text has " + filltype + " fill. Please fill it with an RGB color.";
  }
  o.color = getCssColor(r, g, b);
  return o;
}

function getParagraphStyle(p) {
  // get character style
  var s = getCharStyle(p.characterAttributes);
  // var s = getCharStyle(p.characters[0]);
  // add paragraph-related styles
  s.leading = Math.round(p.leading);
  s.spaceBefore = Math.round(p.spaceBefore);
  s.spaceAfter = Math.round(p.spaceAfter);
  s.justification = String(p.justification);

  // TODO: try to detect opacity.
  // Opacity of text ranges is not detectable via the API.
  // (It is detectable on TextFrames, Groups, Layers, etc)
  // s.opacity = 100;

  return s;
}

// s: style object
function getStyleKey(s) {
  // TODO: improve
  var key = '';
  for (var i=0, n=textStyleKeys.length; i<n; i++) {
    key += '~' + (s[textStyleKeys[i]] || '');
  }
  return key;
}

function getTextStyleClass(style, classes, name) {
  var key = getStyleKey(style);
  var cname = nameSpace + (name || 'style');
  var o, i;
  for (i=0; i<classes.length; i++) {
    o = classes[i];
    if (o.key == key) {
      return o.classname;
    }
  }
  o = {
    key: key,
    style: style,
    classname: cname + i,
    css: generateStyleCss(style)
  };
  classes.push(o);
  return o.classname;
}

// Divide a pg into strings of the same style; capture style data
// for each string of characters and for the entire paragraph
// p: a TextRange object (could be a line or a paragraph)
// pClasses, charClasses: arrays of accumulated css class data
//
function convertParagraph(p, pClasses, charClasses) {
  var pStyle, uniqStyle, html, classname;
  if (p.characters.length === 0) {
    // Handle empty paragraphs
    // It is hard or impossible to know the height of empty paragraphs
    // TODO: Try to estimate the height of empty paragraph and generate
    //    CSS to preserve this height
    classname = "";
    html = "&nbsp;"; // default <p> line height is applied
  } else {
    // TODO: consider basing the pstyle on the most common character style
    // TODO: consider removing the default pg style, or use the most
    //       common detected pg style as the default pg style
    //       (this would require two passes to generate classes)
    pStyle = getParagraphStyle(p);
    html = convertParagraphSegments(getParagraphSegments(p, pStyle, charClasses));
    uniqStyle = getTextStyleDiff(pStyle, defaultParagraphStyle) || {};
    classname = getTextStyleClass(uniqStyle, pClasses, 'aiPstyle');
  }
  return {
    classname: classname,
    html: html
  };
}

// Lookup an AI font name in the font table
function findFontInfo(aifont) {
  for (var k=0; k<fonts.length; k++) {
    if (aifont == fonts[k].aifont) {
      return fonts[k];
    }
  }
  return null;
}

// ai: AI justification value
function getJustificationCss(ai) {
  for (var k=0; k<align.length; k++) {
    if (ai == align[k].ai) {
      return align[k].html;
    }
  }
  return "initial"; // CSS default
}

// ai: AI capitalization value
function getCapitalizationCss(ai) {
  for (k=0; k<caps.length; k++) {
    if (ai == caps[k].ai) {
      return caps[k].html;
    }
  }
  return "";
}

// Convert a parsed style object into a CSS block or inline CSS
// s: style object
// inline: (bool) whether to generate inline CSS or a CSS block
function generateStyleCss(s, inline) {
  var styles = [];
  var fontInfo, css, tmp;
  if (s.aifont && (fontInfo = findFontInfo(s.aifont))) {
    if (fontInfo.family) {
      styles.push("font-family:" + fontInfo.family + ";");
    }
    if (fontInfo.weight) {
      styles.push("font-weight:" + fontInfo.weight + ";");
    }
    if (fontInfo.style) {
      styles.push("font-style:" + fontInfo.style + ";");
    }
  }
  if (s.size > 0) {
    styles.push("font-size:" + s.size + "px;");
  }
  if ('leading' in s) {
    styles.push("line-height:" + s.leading + "px;");
  }
  /*
  if (('opacity' in s) && s.opacity != 100) {
    styles.push("filter: alpha(opacity=" + (s.opacity * 100) + ");");
    styles.push("-ms-filter:'progid:DXImageTransform.Microsoft.Alpha(Opacity=" + (s.opacity) + ")';");
    styles.push("opacity:" + (s.opacity / 100) + ";");
  }
  */
  if (s.spaceBefore > 0) {
    styles.push("padding-top:" + s.spaceBefore + "px;");
  }
  if (s.spaceAfter > 0) {
    styles.push("padding-bottom:" + s.spaceAfter + "px;");
  }
  if (('tracking' in s) && s.tracking !== 0) {
    styles.push("letter-spacing:" + (s.tracking / 1200) + "em;");
  }
  if (s.justification && (tmp = getJustificationCss(s.justification))) {
    styles.push("text-align:" + tmp + ";");
  }
  if (s.capitalization && (tmp = getCapitalizationCss(s.capitalization))) {
    styles.push("text-transform:" + tmp + ";");
  }
  if (s.color) {
    styles.push("color:" + s.color + ";");
  }

  if (!styles.length) {
    css = "";
  } else if (inline) {
    css = styles.join(' ');
  } else {
    css = "\r\t\t\t\t" + styles.join("\r\t\t\t\t") + "\r";
  }
  return css;
}

// Divide a paragraph into segments with the same style
// p: AI paragraph object
// pstyle: parsed paragraph style
// charClasses: array of previously identified css classes
//
function getParagraphSegments(p, pstyle, charClasses) {
  var html = "";
  var segments = [];
  var currRange;
  var prev, curr, diff, c;
  for (var i=0, n=p.characters.length; i<n; i++) {
    c = p.characters[i];
    curr = getCharStyle(c);
    if (!prev || getTextStyleDiff(curr, prev)) {
      diff = getTextStyleDiff(curr, pstyle);
      currRange = {
        text: "",
        // style: diff,
        classname: diff ? getTextStyleClass(diff, charClasses, 'aiCstyle') : ''
        // this would generate inline styles instead of classes
        // css: diff ? generateStyleCss(diff, true) : ''
      };
      // alert(c.characterAttributes.parent.textFrames[0].opacity);
      segments.push(currRange);
      if (curr.warning) {

      }
    }
    if (curr.warning) {
      currRange.warning = curr.warning;
    }
    currRange.text += c.contents;
    prev = curr;
  }
  return segments;
}

function convertParagraphSegments(segments) {
  var html = "", o, cname;
  for (var i=0; i<segments.length; i++) {
    o = segments[i];
    if (o.classname) {
      html += '<span class="' + o.classname + '">' + o.text + '</span>';
    } else { // no css -- same style as enclosing paragraph
      html += o.text;
    }
    if (o.warning) {
      warnings.push(o.warning + " Text: \u201C" + o.text + "\u201D");
    }
  }
  return html;
}


// return styles that are in a but not b
// a, b: style objects
// properties: array of properties to consider
function getTextStyleDiff(a, b) {
  var diff = null;
  for (var k in a) {
    if (a[k] != b[k] && a.hasOwnProperty(k)) {
      diff = diff || {};
      diff[k] = a[k];
    }
  }
  return diff;
}

function getCssColor(r, g, b) {
  return 'rgb(' + r + ',' + g + ',' + b + ')';
}


function textFrameIsRenderable(frame, artboardRect) {
  var good = true;
  if (!testBoundsIntersection(frame.visibleBounds, artboardRect)) {
    good = false;
  } else if (frame.kind != "TextType.AREATEXT" && frame.kind != "TextType.POINTTEXT") {
    good = false;
  } else if (objectIsHidden(frame)) {
    good = false;
  } else if (frame.contents === "") {
    good = false;
  } else if (docSettings.render_rotated_skewed_text_as == "image" && textIsTransformed(frame)) {
    good = false;
  }
  return good;
}


// Find clipped TextFrames that are inside an artboard but outside the bounding box
// box of their clipping path
// texts: array of text objects assocated with a clipping path
// clipRect: bounding box of clipping path
// abRect: bounds of arstboard to test
//
function selectMaskedTextFrames(texts, clipRect, abRect) {
  var found = [];
  var textRect, textInArtboard, textInMask, maskInArtboard;
  for (var i=0; i<texts.length; i++) {
    textRect = texts[i].geometricBounds;
    // capture text items that intersect the artboard but are masked...
    textInArtboard = testBoundsIntersection(abRect, textRect);
    maskInArtboard = testBoundsIntersection(abRect, clipRect);
    textInMask = testBoundsIntersection(textRect, clipRect);
    if (textInArtboard && (!maskInArtboard || !textInMask)) {
      found.push(texts[i]);
    }
  }
  return found;
}

// Assumes mask is unlocked and any other clipping paths are locked
function findTextFramesByClippingPath(mask) {
  var texts = [], selection;
  // Equivalent to Select > Object > Clipping Mask in GUI
  app.executeMenuCommand('Clipping Masks menu item');
  // Equivalent to Object > Clipping Mask > Edit Contents in GUI
  app.executeMenuCommand('editMask');
  selection = doc.selection;
  for (var i=0, n=selection.length; i<n; i++) {
    if (selection[i].typename == 'TextFrame') {
      texts.push(selection[i]);
    }
  }
  doc.selection = null;
  return texts;
}

// Find clipped TextFrames that are inside an artboard but outside their
// clipping path (using bounding box of clipping path to approximate clip area)
function getClippedTextFramesByArtboard(ab) {
  app.executeMenuCommand('Clipping Masks menu item');
  var masks = doc.selection.concat();
  var abRect = ab.artboardRect;
  var frames = [];
  forEach(masks, function(mask) {mask.locked = true;}); // lock clipping paths
  forEach(masks, function(mask) {
    var clipRect = mask.geometricBounds;
    if (testSimilarBounds(abRect, clipRect, 5)) {
      // if clip path is masking to the current artboard, skip the test
      // (optimization)
      return;
    }
    mask.locked = false;
    var texts = findTextFramesByClippingPath(mask);
    texts = selectMaskedTextFrames(texts, clipRect, abRect);
    if (texts.length > 0) {
      frames = frames.concat(texts);
    }
    mask.locked = true;
  });
  forEach(masks, function(mask) {mask.locked = false;}); // unlock clipping paths
  return frames;
}

// Get array of TextFrames belonging to an artboard
function getTextFramesByArtboard(ab) {
  var candidateFrames = findTextFramesToRender(doc.textFrames, ab.artboardRect);
  var excludedFrames = getClippedTextFramesByArtboard(ab);
  var goodFrames = arraySubtract(candidateFrames, excludedFrames);
  return goodFrames;
}

function findTextFramesToRender(frames, artboardRect) {
  var selected = [];
  for (var i=0; i<frames.length; i++) {
    if (textFrameIsRenderable(frames[i], artboardRect)) {
      selected.push(frames[i]);
    }
  }
  // Sort frames top to bottom, left to right.
  selected.sort(
      firstBy(function (v1, v2) { return v2.top  - v1.top; })
      .thenBy(function (v1, v2) { return v1.left - v2.left; })
  );
  return selected;
}

function parseTextFrameNote(note) {
  // Read in attribute variables from notes field of a text frame
  var thisFrameAttributes = {};
  var rawNotes = note.split("\r");
  for (var rNo = 0; rNo < rawNotes.length; rNo++) {
    var rn = rawNotes[rNo];
    var rnKey   = rn.replace( /^[ \t]*([^ \t:]*)[ \t]*:(.*)$/ , "$1" );
    var rnValue = rn.replace( /^[ \t]*([^ \t:]*)[ \t]*:(.*)$/ , "$2" );
    rnKey       = rnKey.replace( /^\s+/ , "" ).replace( /\s+$/ , "" );
    rnValue     = rnValue.replace( /^\s+/ , "" ).replace( /\s+$/ , "" );
    thisFrameAttributes[rnKey] = rnValue;
  }
  return thisFrameAttributes;
}

// Create class="" and style="" CSS for positioning a text div
function getTextPositionCss(thisFrame, artboardRect) {
  var style = "";
  var vFactor = 0.5; // This is an adjustment to correct for vertical placement.
  var kind, htmlY, htmlT, htmlB, htmlTM, htmlH, htmlL, htmlR, htmlW, htmlLM, alignment, extraWidthPct;
  var thisFrameAttributes = parseTextFrameNote(thisFrame.note);
  var abPos = getArtboardPos(artboardRect);

  if (thisFrame.kind=="TextType.POINTTEXT") {
    kind = "point";
    // /this line throws an error if the first paragraph of the frame is empty.
    // var htmlY = Math.round(-thisFrame.position[1] - (((thisFrame.paragraphs[0].characters[0].leading - thisFrame.paragraphs[0].characters[0].size)*vFactor) + thisFrame.paragraphs[0].spaceBefore)-abY);
    htmlY = Math.round(-thisFrame.position[1] - (((thisFrame.characters[0].leading - thisFrame.characters[0].size)*vFactor) + thisFrame.characters[0].spaceBefore) - abPos.y);
  } else if (thisFrame.kind=="TextType.AREATEXT") {
    kind = "area";
    // var htmlY = Math.round(-thisFrame.position[1] - (((thisFrame.paragraphs[0].characters[0].leading - thisFrame.paragraphs[0].characters[0].size)*vFactor) + thisFrame.paragraphs[0].spaceBefore)-abY);
    htmlY = Math.round(-thisFrame.position[1] - (((thisFrame.characters[0].leading - thisFrame.characters[0].size)*vFactor) + thisFrame.characters[0].spaceBefore) - abPos.y);
  } else {
    kind = "other";
  }
  htmlH = Math.round(thisFrame.height);
  if (thisFrameAttributes.valign === "bottom") {
    htmlB = htmlY + thisFrame.height;
  // } else if (thisFrameAttributes.valign==="center") {
  //  htmlT  = htmlY+(thisFrame.height/2);
  //  htmlTM = thisFrame.height*(1/2*-1);
  } else {
    htmlT = htmlY;
  }

  // additional width for box to allow for slight variations in font widths
  if (kind=="area") {
    extraWidthPct = 0; // was 3 percent -- but need to account for when it hits the edge of the box since we are now overflow hidden
  } else {
    extraWidthPct = 100;
  }
  htmlW = thisFrame.width*(1+(extraWidthPct/100));
  if (thisFrame.characters[0].justification=="Justification.LEFT") {
    alignment = "left";
    htmlL = thisFrame.left - abPos.x;
    htmlR = abPos.width - (thisFrame.left + htmlW - abPos.x);
  } else if (thisFrame.characters[0].justification=="Justification.RIGHT") {
    alignment = "right";
    htmlL = thisFrame.left - (thisFrame.width * (1 + (extraWidthPct / 100))) - abPos.x;
    htmlR = abPos.width - (thisFrame.left + thisFrame.width - abPos.x);
  } else if (thisFrame.characters[0].justification=="Justification.CENTER") {
    alignment = "center";
    htmlL  = thisFrame.left - abPos.x +  (thisFrame.width / 2); // thanks jeremy!
    htmlLM = thisFrame.width * (1 + (extraWidthPct/100)) / 2 * -1;
  } else {
    alignment = "other";
    // htmlX = Math.round(thisFrame.left-abX);
  }

  // check if text is transformed
  if (textIsTransformed(thisFrame)) {
    // find transformed anchor point pre-transformation
    var t_bounds = thisFrame.geometricBounds,
      u_bounds = getUntransformedTextBounds(thisFrame),
      u_width = u_bounds[2] - u_bounds[0],
      t_width = t_bounds[2] - t_bounds[0],
      u_height = u_bounds[3] - u_bounds[1],
      t_height = t_bounds[3] - t_bounds[1],
      v_align = thisFrameAttributes.valign || 'top',
      t_scale_x = thisFrame.textRange.characterAttributes.horizontalScale / 100,
      t_scale_y = thisFrame.textRange.characterAttributes.verticalScale / 100,
      t_anchor = getAnchorPoint(u_bounds, thisFrame.matrix, alignment, v_align, t_scale_x, t_scale_y),
      t_trans_x = 0,
      t_trans_y = 0;

    // position div on transformed anchor point
    style += "left:" + round((t_anchor[0] - abPos.x) / abPos.width * 100, pctPrecision) + "%;";
    style += "top:" + round((-t_anchor[1]- abPos.y) / abPos.height * 100, pctPrecision) + "%;";

    // move "back" to left or top to center or right align text
    if (alignment == 'center') t_trans_x -= u_width * 0.5;
    else if (alignment == 'right') t_trans_x -= u_width;
    if (v_align == 'center' || v_align == 'middle') t_trans_y -= u_height * 0.5;
    else if (v_align == 'bottom') t_trans_y -= u_height;

    var mat = thisFrame.matrix;

    mat = app.concatenateMatrix(app.getTranslationMatrix(t_trans_x, t_trans_y),
        app.concatenateTranslationMatrix(mat, -mat.mValueTX, -mat.mValueTY));

    // var mat, mat0 = thisFrame.matrix;
    // mat0 = app.concatenateTranslationMatrix(mat0, -mat0.mValueTX, -mat0.mValueTY);
    // mat = app.concatenateMatrix(app.getTranslationMatrix(t_trans_x, t_trans_y), mat0);

    var transform = "matrix(" +
        round(mat.mValueA, pctPrecision) + ',' +
        round(-1*mat.mValueB, pctPrecision) + ',' +
        round(-1*mat.mValueC, pctPrecision) + ',' +
        round(mat.mValueD, pctPrecision) + ',' +
        round(t_trans_x, pctPrecision) + ',' +
        round(-t_trans_y, pctPrecision) + ') ' +
        "scaleX("+round(t_scale_x, pctPrecision) + ") " +
        "scaleY("+round(t_scale_y, pctPrecision) + ")";

    var transformOrigin = alignment + ' '+(v_align == 'middle' ? 'center' : v_align);

    style += "transform: " + transform + ";";
    style += "transform-origin: " + transformOrigin + ";";
    style += "-webkit-transform: " + transform + ";";
    style += "-webkit-transform-origin: " + transformOrigin + ";";
    style += "-ms-transform: " + transform + ";";
    style += "-ms-transform-origin: " + transformOrigin + ";";

    if (kind == 'area') style += "width: " + (u_width * (1 + (extraWidthPct/100))) + "px;";

  } else {

    if (outputType=="abs") {
      style += "top:" + round(htmlY) + "px;";
      if (alignment=="left") {
        style += "left:"  + round(htmlL) + "px;";
        style += "width:" + round(htmlW) + "px;";
      } else if (alignment=="right") {
        style += "right:" + round(htmlR) + "px;";
        style += "width:" + round(htmlW) + "px;";
      } if (alignment=="center") {
        style += "left:"  + round(htmlL) + "px;";
        style += "width:" + round(htmlW) + "px;";
        style += "margin-left:" + round(htmlLM) + "px;";
      }
    } else if (outputType=="pct") {
      if (thisFrameAttributes.valign==="bottom") {
        style += "bottom:" + round(100 - (htmlB / abPos.height * 100), pctPrecision) + "%;";
      } else {
        style += "top:" + round(htmlT / abPos.height * 100, pctPrecision) + "%;";
      }
      if (alignment=="right") {
        style += "right:" + round(htmlR / abPos.width * 100, pctPrecision) + "%;";
        if (kind=="area") {
          style += "width:" + round(htmlW / abPos.width * 100, pctPrecision) + "%;";
        }
      } else if (alignment=="center") {
        style += "left:" + round(htmlL / abPos.width * 100, pctPrecision) + "%;";
        style += "width:" + round(htmlW / abPos.width * 100, pctPrecision) + "%;";
        style += "margin-left:" + round(htmlLM / abPos.width * 100, pctPrecision) + "%;";
      } else {
        style += "left:" + round(htmlL / abPos.width * 100, pctPrecision) + "%;";
        if (kind=="area") {
          style += "width:" + round(htmlW / abPos.width * 100, pctPrecision) + "%;";
        }
      }
    }
  }
  var frameLayer = makeKeyword(thisFrame.layer.name);
  return 'class="' + nameSpace + frameLayer + " " + nameSpace + "aiAbs" +
    (textIsTransformed(thisFrame) && kind == "point" ? ' g-aiPtransformed' : '') +
    '" style="' + style + '"';
}

function getAnchorPoint(untransformedBounds, matrix, hAlign, vAlign, sx, sy) {
  var center_x = (untransformedBounds[0] + untransformedBounds[2]) * 0.5,
    center_y = (untransformedBounds[1] + untransformedBounds[3]) * 0.5,
    anchor_x = (hAlign == 'left' ? untransformedBounds[0] :
      (hAlign == 'center' ? center_x : untransformedBounds[2])),
    anchor_y = (vAlign == 'top' ? untransformedBounds[1] :
      (vAlign == 'bottom' ? untransformedBounds[3] : center_y)),
    anchor_dx = (anchor_x - center_x),
    anchor_dy = (anchor_y - center_y);

  var mat = app.concatenateMatrix(app.getScaleMatrix(sx*100, sy*100), matrix);

  var t_anchor_x = center_x + mat.mValueA * anchor_dx + mat.mValueC * anchor_dy,
    t_anchor_y = center_y + mat.mValueB * anchor_dx + mat.mValueD * anchor_dy;

  return [t_anchor_x, t_anchor_y];
}

function getUntransformedTextBounds(textFrame) {
  var oldSelection = activeDocument.selection;
  activeDocument.selection = [textFrame];
  app.copy();
  app.paste(); // See Issue #50 https://github.com/newsdev/ai2html/issues/50
  var textFrameCopy = activeDocument.selection[0];
  // move to same position
  textFrameCopy.left = textFrame.left;
  textFrameCopy.top = textFrame.top;
  var bnds = textFrameCopy.geometricBounds;

  var old_center_x = (bnds[0] + bnds[2]) * 0.5,
    old_center_y = (bnds[1] + bnds[3]) * 0.5;

  // inverse transformation of copied text frame
  textFrameCopy.transform(app.invertMatrix(textFrame.matrix));
  // remove scale
  textFrameCopy.textRange.characterAttributes.horizontalScale = 100;
  textFrameCopy.textRange.characterAttributes.verticalScale = 100;
  // move transformed text frame back to old center point
  var new_center_x, new_center_y;
  var max_iter = 5;

  while (--max_iter > 0) {
    bnds = textFrameCopy.geometricBounds;
    new_center_x = (bnds[0] + bnds[2]) * 0.5;
    new_center_y = (bnds[1] + bnds[3]) * 0.5;
    textFrameCopy.translate(old_center_x - new_center_x, old_center_y - new_center_y);
  }

  var bounds = textFrameCopy.geometricBounds;
  textFrameCopy.textRange.characterAttributes.fillColor = getRGBColor(250, 50, 50);
  textFrameCopy.remove();

  // reset selection
  activeDocument.selection = oldSelection;
  return bounds;
}

// ==============================
// ai2html artboard functions
// ==============================

// return rect of bounding box of all artboards
function getArtboardBounds() {
  var rect, bounds;
  for (var i=0, n=doc.artboards.length; i<n; i++) {
    rect = doc.artboards[i].artboardRect;
    if (i === 0) {
      bounds = rect;
    } else {
      bounds = [
        Math.min(rect[0], bounds[0]), Math.max(rect[1], bounds[1]),
        Math.max(rect[2], bounds[2]), Math.min(rect[3], bounds[3])];
    }
  }
  return bounds;
}

// return array info about each usable artboard, sorted from narrow to wide
function getArtboardInfo() {
  var artboards = [];
  forEachArtboard(function(ab, i) {
    var pos = getArtboardPos(ab.artboardRect);
    var name = ab.name || "";
    // parse width from artboard name in two formats: <name>:<width> and ai2html-<width>
    var widthFromName = (/^(?:.*:|ai2html-)(\d+)$/.exec(name) || [])[1];
    artboards.push({
      name: ab.name || "",
      width: pos.width,
      effectiveWidth: widthFromName ? +widthFromName : pos.width,
      id: i
    });
  });
  artboards.sort(function(a, b) {return a.effectiveWidth - b.effectiveWidth});
  return artboards;
}

function findShowClassesByArtboardId(id, breakpoints) {
  var classes = [];
  forEach(breakpoints, function(bp) {
    if (bp.artboards.indexOf(id) > -1) {
      classes.push('g-show-' + bp.name);
    }
  });
  return classes.join(' ');
}

// Get array of data records about breakpoints with artboards assigned to them
// (sorted from narrow to wide)
function assignBreakpointsToArtboards(breakpoints) {
  var abArr = getArtboardInfo(); // get data records for each artboard
  var bpArr = [];
  forEach(breakpoints, function(breakpoint) {
    var bpPrev = bpArr[bpArr.length - 1],
        bpInfo = {
          name: breakpoint.name,
          range: [breakpoint.lowerLimit, breakpoint.upperLimit],
          artboards: []
        },
        abInfo;
    for (var i=0; i<abArr.length; i++) {
      abInfo = abArr[i];
      if (abInfo.effectiveWidth <= breakpoint.upperLimit &&
          abInfo.effectiveWidth > breakpoint.lowerLimit) {
        bpInfo.artboards.push(abInfo.id);
      }
    }
    if (bpInfo.artboards.length > 1 && docSettings.ai2html_environment=="nyt") {
      warnings.push('The ' + breakpoint.upperLimit + "px breakpoint has " + bpInfo.artboards.length + " artboards. You probably want only one artboard per breakpoint.");
    }
    if (bpInfo.artboards.length === 0 && bpPrev) {
      bpInfo.artboards = bpPrev.artboards.concat();
    }
    if (bpInfo.artboards.length > 0) {
      bpArr.push(bpInfo);
    }
  });
  return bpArr;
}

function artboardIsUsable(ab) {
	return ab.name.search(/^-/) == -1;
}

function forEachArtboard(cb) {
	var ab;
	for (var i=0; i<doc.artboards.length; i++) {
		ab = doc.artboards[i];
		if (artboardIsUsable(ab)) {
			cb(ab, i);
		}
	}
}

// Returns id of largest artboard
function findLargestArtboard() {
  var largestId = -1;
  var largestArea = 0;
  forEachArtboard(function(ab, i) {
    var info = getArtboardPos(ab.artboardRect);
    var area = info.width * info.height;
    if (area > largestArea) {
      largestId = i;
      largestArea = area;
    }
  });
  return largestId;
}

function hideElementsOutsideArtboardRect(artboardRect) {
  var hidden = [];
  forEachLayer(function(layer) {
    if (layer.visible) { // only deal with visible layers
      forEach(layer.pathItems, hideIfOutside);
      forEach(layer.symbolItems, hideIfOutside);
      forEach(layer.compoundPathItems, hideIfOutside);
      forEach(layer.groupItems, hideOutsideGroup);
    }
  });
  function hideIfOutside(item) {
    if (!testBoundsIntersection(item.visibleBounds, artboardRect)) {
      item.hidden = true;
      hidden.push(item);
    }
  }
  function hideOutsideGroup(group) {
    hideIfOutside(group);
    forEach(group.groupItems, hideOutsideGroup);
  }
  return hidden;
}


// =================================
// ai2html image functions
// =================================


// Create a promo image from the largest usable artboard
function createPromoImage() {
	var PROMO_WIDTH = 1024;
	var abNumber = findLargestArtboard();
	if (abNumber == -1) return; // TODO: show error

	var artboard         =  doc.artboards[abNumber],
			abPos            =  getArtboardPos(artboard.artboardRect),
			promoScale       =  PROMO_WIDTH / abPos.width,
			promoW           =  abPos.width * promoScale,
			promoH           =  abPos.height * promoScale,
			imageDestination =  docPath + docSettings.docName + "-promo",
			promoFormat, tmpPngTransparency;

	// Previous file name was more complicated:
	// imageDestination = docPath + docSettings.docName + "-" + makeKeyword(ab.name) + "-" + abNumber + "-promo";

	doc.artboards.setActiveArtboardIndex(abNumber);

	// Using "jpg" if present in image_format setting, else using "png";
	if (docSettings.image_format.indexOf('jpg') > -1) {
		promoFormat = 'jpg';
	} else {
		promoFormat = 'png';
	}

	tmpPngTransparency = docSettings.png_transparent;
	docSettings.png_transparent = "no";
	exportImageFiles(imageDestination, promoW, promoH, [promoFormat], promoScale, "no");
	docSettings.png_transparent = tmpPngTransparency;
	alert("Promo image created\nLocation: " + imageDestination + "." + promoFormat);
}

// Exports contents of active artboard (without text, unless in test mode)
// dest: full path of output file including the file basename
// width, height: the artboard width and height and only used to determine whether or not to use double res
// formats: array of export format identifiers (png, png24, jpg, svg)
// initialScaling: the proportion to scale the base image before considering whether to double res. Usually just 1.
// doubleres: "yes" or "no" whether you want to allow images to be double res
//            to force ai2html to use doubleres, use "always"
//
function exportImageFiles(dest,width,height,formats,initialScaling,doubleres) {
   // max JPG scale is specified in the Javascript Object Reference under ExportOptionsJPEG.
  var maxJpgImageScaling  = 776.19;
  var pngScaling = 100 * initialScaling,
      jpgScaling = 100 * initialScaling,
      exportOptions, fileType;

  if (doubleres=="yes" || doubleres=="always") {
    pngScaling = 200 * initialScaling;
    jpgScaling = 200 * initialScaling;
    // if image is too big to use double-res, then just output single-res.
    if (doubleres == 'always' || ((width*height) < (3*1024*1024/4) || (width >= 945))) {
      // <3
      // feedback.push("The jpg and png images are double resolution.");
    } else if ( (width*height) < (3*1024*1024) ) {
      // .75-3
      pngScaling = 100;
      // feedback.push("The png image is single resolution.");
      // feedback.push("The jpg image is double resolution.");
    } else if ( (width*height) < (32*1024*1024/4) ) {
      // 3-8
      pngScaling = 100;
      // warnings.push("The png image is single resolution, but is too large to display on first-generation iPhones.");
      // feedback.push("The jpg image is double resolution.");
    } else if ( (width*height) < (32*1024*1024) ) {
      // 8-32
      pngScaling = 100;
      jpgScaling = 100;
      // warnings.push("The png image is single resolution, but is too large to display on first-generation iPhones.");
      // feedback.push("The jpg image is single resolution.");
    } else {
      // 32+
      pngScaling = 100;
      jpgScaling = 100;
      // warnings.push("The jpg and png images are single resolution, but are too large to display on first-generation iPhones.");
    }
  }

  for (var formatNumber = 0; formatNumber < formats.length; formatNumber++) {
    var format = formats[formatNumber];
    if (format=="png") {
      exportOptions = new ExportOptionsPNG8();
      fileType = ExportType.PNG8;
      exportOptions.colorCount       = docSettings.png_number_of_colors;
      exportOptions.transparency     = (docSettings.png_transparent==="no") ? false : true;
      exportOptions.artBoardClipping = true;
      exportOptions.antiAliasing     = false;
      exportOptions.horizontalScale  = pngScaling;
      exportOptions.verticalScale    = pngScaling;
      // feedback.push("exportOptions.png_number_of_colors = " + exportOptions.colorCount);
      // feedback.push("exportOptions.transparency = " + exportOptions.transparency);

    } else if (format=="png24") {
      exportOptions = new ExportOptionsPNG24();
      fileType = ExportType.PNG24;
      exportOptions.transparency     = (docSettings.png_transparent==="no") ? false : true;
      exportOptions.artBoardClipping = true;
      exportOptions.antiAliasing     = false;
      exportOptions.horizontalScale  = pngScaling;
      exportOptions.verticalScale    = pngScaling;

    } else if (format=="svg") {
      fileType = ExportType.SVG;
      exportOptions = new ExportOptionsSVG();
      exportOptions.embedAllFonts         = false;
      exportOptions.fontSubsetting        = SVGFontSubsetting.None;
      exportOptions.compressed            = false;
      exportOptions.documentEncoding      = SVGDocumentEncoding.UTF8;
      exportOptions.embedRasterImages     = (docSettings.svg_embed_images==="yes") ? true : false;
      // exportOptions.horizontalScale       = initialScaling;
      // exportOptions.verticalScale         = initialScaling;
      exportOptions.saveMultipleArtboards = false;
      exportOptions.DTD                   = SVGDTDVersion.SVG1_1; // SVG1_0 SVGTINY1_1 <=default SVG1_1 SVGTINY1_1PLUS SVGBASIC1_1 SVGTINY1_2
      exportOptions.cssProperties         = SVGCSSPropertyLocation.STYLEATTRIBUTES; // ENTITIES STYLEATTRIBUTES <=default PRESENTATIONATTRIBUTES STYLEELEMENTS

    } else if (format=="jpg") {
      if (jpgScaling > maxJpgImageScaling) {
        jpgScaling = maxJpgImageScaling;
        var promoImageFileName = dest.split("/").slice(-1)[0];
        feedback.push(promoImageFileName + ".jpg was output at a lower scaling than desired because of a limit on jpg exports in Illustrator. If the file needs to be larger, change the image format to png which does not appear to have limits.");
      }
      fileType = ExportType.JPEG;
      exportOptions = new ExportOptionsJPEG();
      exportOptions.artBoardClipping = true;
      exportOptions.antiAliasing     = false;
      exportOptions.qualitySetting   = docSettings.jpg_quality;
      exportOptions.horizontalScale  = jpgScaling;
      exportOptions.verticalScale    = jpgScaling;

    } else {
      warnings.push("Unsupported image format: " + format);
      continue;
    }
    app.activeDocument.exportFile(new File(dest), fileType, exportOptions);
  }
}


// ===================================
// ai2html output generation functions
// ===================================

function generateYmlFileContent(breakpoints, settings) {
  var lines = [];
  lines.push("ai2html_version: " + scriptVersion);
  lines.push("project_type: " + previewProjectType);
  lines.push("tags: ai2html");
  lines.push("min_width: " + breakpoints[0].range[1]); // TODO: ask why upperLimit
  if (settings.max_width !== "") {
    lines.push("max_width: " + docSettings.max_width);
  } else if (docSettings.responsiveness != "fixed" && docSettings.ai2html_environment == "nyt") {
    lines.push("max_width: " + breakpoints[breakpoints.length-1].range[1]);
  } else if (docSettings.responsiveness != "fixed" && docSettings.ai2html_environment != "nyt") {
    // don't write a max_width setting as there should be no max width in this case
  } else {
    // this is the case of fixed responsiveness
    lines.push("max_width: " + getArtboardInfo().pop().effectiveWidth);
  }
  // write out remaining values for config file
  for (setting in settings) {
    if (setting in ai2htmlBaseSettings && ai2htmlBaseSettings[setting].includeInConfigFile) {
      var quoteMark = ai2htmlBaseSettings[setting].useQuoteMarksInConfigFile ? '"': '';
      lines.push(setting + ': ' + quoteMark + settings[setting] + quoteMark);
    }
  }
  return lines.join('\n') + '\n';
}

function applyTemplate(template, atObject) {
	var newText = template;
	for (var atKey in atObject) {
		var mustachePattern = new RegExp("\\{\\{\\{? *" + atKey + " *\\}\\}\\}?","g");
		var ejsPattern      = new RegExp("\\<\\%[=]? *" + atKey + " *\\%\\>","g");
		var replacePattern  = atObject[atKey];
		newText = newText.replace( mustachePattern , replacePattern );
		newText = newText.replace( ejsPattern      , replacePattern );
	}
	return newText;
}

function outputHtml(htmlText, fileDestination) {
	var htmlFile = new File(fileDestination);
	htmlFile.open("w", "TEXT", "TEXT");
	htmlFile.lineFeed = "Unix";
	htmlFile.encoding = "UTF-8";
	htmlFile.writeln(htmlText);
	htmlFile.close();
}

function checkForOutputFolder(folderPath, nickname) {
	var outputFolder = new Folder( folderPath );
	if (!outputFolder.exists) {
		var outputFolderCreated = outputFolder.create();
		if (outputFolderCreated) {
			feedback.push("The " + nickname + " folder did not exist, so the folder was created.");
		} else {
			warnings.push("The " + nickname + " folder did not exist and could not be created.");
		}
	}
}

function getResizerScript() {
	var f = function(scriptEnvironment) {
	  // only want one resizer on the page
	  if (document.documentElement.className.indexOf("g-resizer-v3-init") > -1) return;
	  document.documentElement.className += " g-resizer-v3-init";
	  // require IE9+
	  if (!("querySelector" in document)) return;
	  function resizer() {
	    var elements = Array.prototype.slice.call(document.querySelectorAll(".g-artboard-v3[data-min-width]")),
	        widthById = {};
	    elements.forEach(function(el) {
	      var parent = el.parentNode,
	          width = widthById[parent.id] || parent.getBoundingClientRect().width,
	          minwidth = el.getAttribute("data-min-width"),
	          maxwidth = el.getAttribute("data-max-width");
	      widthById[parent.id] = width;

	      if (+minwidth <= width && (+maxwidth >= width || maxwidth === null)) {
	        var img = el.querySelector(".g-aiImg");
	        if (img.getAttribute("data-src") && img.getAttribute("src") != img.getAttribute("data-src")) {
	          img.setAttribute("src", img.getAttribute("data-src"));
	        }
	        el.style.display = "block";
	      } else {
	        el.style.display = "none";
	      }
	    });

	    if (scriptEnvironment=="nyt") {
	      try {
	        if (window.parent && window.parent.$) {
	          window.parent.$("body").trigger("resizedcontent", [window]);
	        }
	        document.documentElement.dispatchEvent(new Event("resizedcontent"));
	        if (window.require && document.querySelector("meta[name=sourceApp]") && document.querySelector("meta[name=sourceApp]").content == "nyt-v5") {
	          require(["foundation/main"], function() {
	            require(["shared/interactive/instances/app-communicator"], function(AppCommunicator) {
	              AppCommunicator.triggerResize();
	            });
	          });
	        }
	      } catch(e) { console.log(e); }
	    }
	  }

	  resizer();
	  document.addEventListener("DOMContentLoaded", resizer);
	  // feel free to replace throttle with _.throttle, if available
	  window.addEventListener("resize", throttle(resizer, 200));

	  function throttle(func, wait) {
	    // from underscore.js
	    var _now = Date.now || function() { return new Date().getTime(); },
	        context, args, result, timeout = null, previous = 0;
	    var later = function() {
	        previous = _now();
	        timeout = null;
	        result = func.apply(context, args);
	        if (!timeout) context = args = null;
	    };
	    return function() {
	      var now = _now(), remaining = wait - (now - previous);
	      context = this;
	      args = arguments;
	      if (remaining <= 0 || remaining > wait) {
	        if (timeout) {
	          clearTimeout(timeout);
	          timeout = null;
	        }
	        previous = now;
	        result = func.apply(context, args);
	        if (!timeout) context = args = null;
	      } else if (!timeout) {
	        timeout = setTimeout(later, remaining);
	      }
	      return result;
	    };
	  }
	};

	// convert function to JS source code
	var js = '\t(' + trim(f.toString()) + ')("' + (scriptEnvironment || '') + '");';
	return '<script type="text/javascript">\n' + js + '\n\t</script>\n\n';
}


// Write an HTML page to a file for NYT Preview
function outputLocalPreviewPage(textForFile, localPreviewDestination, docSettings) {
	var localPreviewTemplateText = readTextFile(docPath + docSettings.local_preview_template);
	docSettings.ai2htmlPartial = textForFile; // TODO: don't modify global settings this way
	var localPreviewHtml = applyTemplate(localPreviewTemplateText, docSettings);
	outputHtml(localPreviewHtml, localPreviewDestination);
}

function getPageContent(artboardHtml, customHtml, customJs, customCss) {
	var content = "";
	if (customCss) {
		content += "\r\t<style type='text/css' media='screen,print'>\r" + customCss + "\t</style>\r";
	}
	content += artboardHtml;
	if (customHtml) content += customHtml + '\r';
	if (customJs) content += customJs + '\r';
	return content;
}

function getContentHeader(docKey, docSettings) {
	var headerText = "\t<!-- Generated by ai2html v" + scriptVersion + " - " + getDateTimeStamp() + " -->\r";
	headerText += "\t<!-- ai file: " + docSettings.project_name + " -->\r";
	if (docSettings.ai2html_environment == "nyt") {
		headerText += "\t<!-- preview: " + docSettings.preview_slug + " -->\r";
		headerText += "\t<!-- scoop  : " + docSettings.scoop_slug_from_config_yml + " -->\r";
	}
	headerText += "\r";
	headerText += "\t<style type='text/css' media='screen,print'>\r";
	if (docSettings.max_width !== "") {
		headerText += "\t\t#" + nameSpace + docKey + "-box {\r";
		headerText += "\t\t\tmax-width:" + docSettings.max_width + "px;\r";
		headerText += "\t\t}\r";
	}
	if (docSettings.center_html_output) {
		headerText += "\t\t." + nameSpace + "artboard {\r";
		headerText += "\t\t\tmargin:0 auto;\r";
		headerText += "\t\t}\r";
	}
	if (docSettings.clickable_link !== "") {
		headerText += "\t\t." + nameSpace + "ai2htmlLink {\r";
		headerText += "\t\t\tdisplay: block;\r";
		headerText += "\t\t}\r";
	}
	headerText += "\t</style>\r";
	headerText += "\r";

	return headerText;
}

// Wrap content HTML in a <div>, add styles and resizer script, write to a file
function generateHtml(pageContent, docName, docSettings) {

	var multiMode = docSettings.output == 'multiple-files';
	var linkSrc = docSettings.clickable_link || "";
	var docKey = makeKeyword(docName);
	var textForFile = "";
	var responsiveCss = "";
	var responsiveJs = "";
	var htmlFileDestination, htmlFileDestinationFolder;

	pBar.setTitle('Writing HTML output...');

	if (docSettings.ai2html_environment == "nyt" && docSettings.include_resizer_css_js != "no") {
		responsiveJs = '\t<script src="_assets/resizerScript.js"></script>' + "\n";
		if (previewProjectType == "ai2html") {
			responsiveCss = '\t<link rel="stylesheet" href="_assets/resizerStyle.css">' + "\n";
		}
	}
	if (docSettings.include_resizer_script=="yes") {
		responsiveJs  = '\t' + getResizerScript() + '\n';
		responsiveCss = "";
	}

	// wrap content in a <div> tag
	textForFile += "<div id='" + nameSpace + docKey + "-box' class='ai2html'>\r";
	textForFile += getContentHeader(docKey, docSettings);

	// optional link around content
	if (linkSrc) {
		textForFile += "\t<a class='" + nameSpace + "ai2htmlLink' href='" + linkSrc + "'>\r";
	}

	textForFile += responsiveCss;
	textForFile += pageContent;
	textForFile += responsiveJs;

	if (linkSrc) {
		textForFile += "\t</a>\r";
	}

	// close <div>
	textForFile += "\t<!-- End ai2html" + " - " + getDateTimeStamp() + " -->\r</div>\r";

	textForFile = applyTemplate(textForFile, docSettings);

	htmlFileDestinationFolder = docPath + docSettings.html_output_path;
	checkForOutputFolder(htmlFileDestinationFolder, "html_output_path");
	htmlFileDestination = htmlFileDestinationFolder + docKey + docSettings.html_output_extension;

	if (multiMode && previewProjectType == 'ai2html') {
		htmlFileDestination = htmlFileDestinationFolder + "index" + docSettings.html_output_extension;
	}

	// write file
	outputHtml(textForFile, htmlFileDestination);

	// process local preview template if appropriate
	if (docSettings.local_preview_template !== "") {
		// TODO: may have missed a condition, need to compare with original version
		var previewFileDestination = htmlFileDestinationFolder + docKey + ".preview.html";
		outputLocalPreviewPage(textForFile, previewFileDestination, docSettings);
	}
}
