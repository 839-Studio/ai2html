// ai2html.js
var scriptVersion     = "0.70";

// ai2html is a script for Adobe Illustrator that converts your Illustrator document into html and css.
// Copyright (c) 2011-2015 The New York Times Company
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this library except in compliance with the License.
// You may obtain a copy of the License at

// http://www.apache.org/licenses/LICENSE-2.0

// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

// =====================================
// How to install ai2html
// =====================================

// - Move the ai2html.js file into the Illustrator folder where scripts are located.
// - For example, on Mac OS X running Adobe Illustrator CC 2014, the path would be: // Adobe Illustrator CC 2014/Presets/en_US/Scripts/ai2html.jsx

// =====================================
// How to use ai2html
// =====================================

// - Create your Illustrator artwork.
// - Size the artboard to the dimensions that you want the div to appear on the web page.
// - Make sure your Document Color Mode is set to RGB.
// - Make sure your document is saved.
// - Use Arial or Georgia unless you have added your own fonts to the fonts array in the script.
// - Run the script by choosing: File > Scripts > ai2html
// - Go to the folder containing your Illustrator file. Inside will be a folder called ai2html-output.
// - Open the html files in your browser to preview your output.


// ================================================
// ai2html and config settings
// ================================================

// Settings can be generated by making a copy of this Google Spreadsheet:
// https://docs.google.com/spreadsheets/d/13ESQ9ktfkdzFq78FkWLGaZr2s3lNbv2cN25F2pYf5XM/edit?usp=sharing
// Make a copy of the spreadsheet for yourself.
// Modify the settings to taste.
// Copy the contents from column Images and replace the settings statements:
var nytBaseSettings = {
  ai2html_environment: {defaultValue: scriptEnvironment, includeInSettingsBlock: false, includeInConfigFile: false, useQuoteMarksInConfigFile: false, inputType: "text", possibleValues: "", notes: ""},
  settings_version: {defaultValue: scriptVersion, includeInSettingsBlock: true, includeInConfigFile: false, useQuoteMarksInConfigFile: false, inputType: "text", possibleValues: "", notes: ""},
  create_promo_image: {defaultValue: "no", includeInSettingsBlock: false, includeInConfigFile: false, useQuoteMarksInConfigFile: false, inputType: "text", possibleValues: "", notes: ""},
  image_format: {defaultValue: ["png"], includeInSettingsBlock: true, includeInConfigFile: false, useQuoteMarksInConfigFile: false, inputType: "array", possibleValues: "jpg, png, png24", notes: "Images will be generated in mulitple formats if multiple formats are listed, separated by commas. The first format will be used in the html. Sometimes this is useful to compare which format will have a smaller file size."},
  write_image_files: {defaultValue: "yes", includeInSettingsBlock: true, includeInConfigFile: false, useQuoteMarksInConfigFile: false, inputType: "yesNo", possibleValues: "", notes: "Set this to \u201Cno\u201D to skip writing the image files. Generally only use this after you have run the script once with this setting set to \u201Cyes.\u201D"},
  responsiveness: {defaultValue: "fixed", includeInSettingsBlock: true, includeInConfigFile: false, useQuoteMarksInConfigFile: false, inputType: "text", possibleValues: "fixed, dynamic", notes: "Dynamic responsiveness means ai graphics will scale to fill the container they are placed in."},
  max_width: {defaultValue: "", includeInSettingsBlock: true, includeInConfigFile: false, useQuoteMarksInConfigFile: false, inputType: "integer", possibleValues: "", notes: "Blank or any positive number in pixels, but do not write \u201Cpx\u201D - blank means artboards will set max size, instead it is written to the config file so that the max width can be applied to the template’s container."},
  output: {defaultValue: "one-file", includeInSettingsBlock: true, includeInConfigFile: false, useQuoteMarksInConfigFile: false, inputType: "text", possibleValues: "one-file, multiple-files", notes: "One html file containing all the artboards or a separate html file for each artboard."},
  project_name: {defaultValue: "", includeInSettingsBlock: false, includeInConfigFile: false, useQuoteMarksInConfigFile: false, inputType: "text", possibleValues: "", notes: "Use this to set a custom project name. The project name is being used in output filenames, class names, etc."},
  html_output_path: {defaultValue: "../src/", includeInSettingsBlock: false, includeInConfigFile: false, useQuoteMarksInConfigFile: false, inputType: "folderPath", possibleValues: "", notes: "Allows user to change folder to write html files, path should be written relative to ai file location. This is ignored if the project_type in the yml is ai2html."},
  html_output_extension: {defaultValue: ".html", includeInSettingsBlock: false, includeInConfigFile: false, useQuoteMarksInConfigFile: false, inputType: "fileExtension", possibleValues: "", notes: "This is ignored if the project_type in the yml is ai2html."},
  image_output_path: {defaultValue: "../public/_assets/", includeInSettingsBlock: false, includeInConfigFile: false, useQuoteMarksInConfigFile: false, inputType: "folderPath", possibleValues: "", notes: "_assets/ for preview default. This is where the image files get written to locally and should be written as if the html_output location is the starting point."},
  image_source_path: {defaultValue: null, includeInSettingsBlock: false, includeInConfigFile: false, useQuoteMarksInConfigFile: false, inputType: "folderPath", possibleValues: "", notes: "Use this setting to specify from where the images are being loaded from the HTML file. Defaults to image_output_path"},
  create_config_file: {defaultValue: "true", includeInSettingsBlock: false, includeInConfigFile: false, useQuoteMarksInConfigFile: false, inputType: "trueFalse", possibleValues: "", notes: "This is ignored in env=nyt."},
  config_file_path: {defaultValue: "../config.yml", includeInSettingsBlock: false, includeInConfigFile: false, useQuoteMarksInConfigFile: false, inputType: "filePath", possibleValues: "", notes: "This only gets used to write the config file. It’s not used in the nyt mode to read the config.yml. Path should written relative to the ai file location."},
  local_preview_template: {defaultValue: "", includeInSettingsBlock: false, includeInConfigFile: false, useQuoteMarksInConfigFile: false, inputType: "filePath", possibleValues: "", notes: ""},
  png_transparent: {defaultValue: "no", includeInSettingsBlock: false, includeInConfigFile: false, useQuoteMarksInConfigFile: false, inputType: "yesNo", possibleValues: "", notes: ""},
  png_number_of_colors: {defaultValue: 128, includeInSettingsBlock: true, includeInConfigFile: false, useQuoteMarksInConfigFile: false, inputType: "integer", possibleValues: "2 to 256", notes: ""},
  jpg_quality: {defaultValue: 60, includeInSettingsBlock: true, includeInConfigFile: false, useQuoteMarksInConfigFile: false, inputType: "integer", possibleValues: "0 to 100", notes: ""},
  center_html_output: {defaultValue: "true", includeInSettingsBlock: false, includeInConfigFile: false, useQuoteMarksInConfigFile: false, inputType: "text", possibleValues: "", notes: "Adds \u201Cmargin:0 auto;\u201D to the div containing the ai2html output."},
  use_2x_images_if_possible: {defaultValue: "yes", includeInSettingsBlock: false, includeInConfigFile: false, useQuoteMarksInConfigFile: false, inputType: "yesNo", possibleValues: "", notes: ""},
  use_lazy_loader: {defaultValue: "no", includeInSettingsBlock: false, includeInConfigFile: false, useQuoteMarksInConfigFile: false, inputType: "yesNo", possibleValues: "", notes: ""},
  include_resizer_css_js: {defaultValue: "yes", includeInSettingsBlock: false, includeInConfigFile: false, useQuoteMarksInConfigFile: false, inputType: "yesNo", possibleValues: "", notes: ""},
  include_resizer_classes: {defaultValue: "no", includeInSettingsBlock: false, includeInConfigFile: false, useQuoteMarksInConfigFile: false, inputType: "yesNo", possibleValues: "", notes: ""},
  include_resizer_widths: {defaultValue: "yes", includeInSettingsBlock: false, includeInConfigFile: false, useQuoteMarksInConfigFile: false, inputType: "yesNo", possibleValues: "", notes: ""},
  include_resizer_script: {defaultValue: "yes", includeInSettingsBlock: false, includeInConfigFile: false, useQuoteMarksInConfigFile: false, inputType: "yesNo", possibleValues: "", notes: ""},
  svg_embed_images: {defaultValue: "no", includeInSettingsBlock: false, includeInConfigFile: false, useQuoteMarksInConfigFile: false, inputType: "yesNo", possibleValues: "", notes: ""},
  render_rotated_skewed_text_as: {defaultValue: "html", includeInSettingsBlock: false, includeInConfigFile: false, useQuoteMarksInConfigFile: false, inputType: "text", possibleValues: "image, html", notes: ""},
  show_completion_dialog_box: {defaultValue: "true", includeInSettingsBlock: true, includeInConfigFile: false, useQuoteMarksInConfigFile: false, inputType: "trueFalse", possibleValues: "", notes: "Set this to false if you don't want to see the dialog box confirming completion of the script."},
  clickable_link: {defaultValue: "", includeInSettingsBlock: false, includeInConfigFile: false, useQuoteMarksInConfigFile: false, inputType: "text", possibleValues: "", notes: "If you put a url in this field, an <a> tag will be added, wrapping around the output and pointing to that url."},
  testing_mode: {defaultValue: "no", includeInSettingsBlock: false, includeInConfigFile: false, useQuoteMarksInConfigFile: false, inputType: "yesNo", possibleValues: "", notes: ""},
  last_updated_text: {defaultValue: "", includeInSettingsBlock: true, includeInConfigFile: true, useQuoteMarksInConfigFile: true, inputType: "text", possibleValues: "", notes: ""},
  headline: {defaultValue: "", includeInSettingsBlock: true, includeInConfigFile: true, useQuoteMarksInConfigFile: true, inputType: "text", possibleValues: "", notes: ""},
  leadin: {defaultValue: "", includeInSettingsBlock: true, includeInConfigFile: true, useQuoteMarksInConfigFile: true, inputType: "text", possibleValues: "", notes: ""},
  summary: {defaultValue: "", includeInSettingsBlock: true, includeInConfigFile: true, useQuoteMarksInConfigFile: true, inputType: "text", possibleValues: "", notes: "Summary field for Scoop assets"},
  notes: {defaultValue: "", includeInSettingsBlock: true, includeInConfigFile: true, useQuoteMarksInConfigFile: true, inputType: "text", possibleValues: "", notes: ""},
  sources: {defaultValue: "", includeInSettingsBlock: true, includeInConfigFile: true, useQuoteMarksInConfigFile: true, inputType: "text", possibleValues: "", notes: ""},
  credit: {defaultValue: "By The New York Times", includeInSettingsBlock: true, includeInConfigFile: true, useQuoteMarksInConfigFile: true, inputType: "text", possibleValues: "", notes: ""},
  page_template: {defaultValue: "nyt5-article-embed", includeInSettingsBlock: true, includeInConfigFile: true, useQuoteMarksInConfigFile: false, inputType: "text", possibleValues: "", notes: ""},
  publish_system: {defaultValue: "scoop", includeInSettingsBlock: false, includeInConfigFile: true, useQuoteMarksInConfigFile: false, inputType: "text", possibleValues: "", notes: ""},
  environment: {defaultValue: "production", includeInSettingsBlock: false, includeInConfigFile: true, useQuoteMarksInConfigFile: false, inputType: "text", possibleValues: "", notes: ""},
  show_in_compatible_apps: {defaultValue: "yes", includeInSettingsBlock: true, includeInConfigFile: true, useQuoteMarksInConfigFile: true, inputType: "yesNo", possibleValues: "", notes: ""},
  display_for_promotion_only: {defaultValue: "false", includeInSettingsBlock: true, includeInConfigFile: true, useQuoteMarksInConfigFile: false, inputType: "trueFalse", possibleValues: "", notes: ""},
  constrain_width_to_text_column: {defaultValue: "false", includeInSettingsBlock: true, includeInConfigFile: true, useQuoteMarksInConfigFile: false, inputType: "trueFalse", possibleValues: "", notes: ""},
  scoop_publish_fields: {defaultValue: "true", includeInSettingsBlock: false, includeInConfigFile: true, useQuoteMarksInConfigFile: false, inputType: "trueFalse", possibleValues: "", notes: ""},
  scoop_asset_id: {defaultValue: "", includeInSettingsBlock: true, includeInConfigFile: true, useQuoteMarksInConfigFile: false, inputType: "text", possibleValues: "", notes: ""},
  scoop_username: {defaultValue: "", includeInSettingsBlock: true, includeInConfigFile: true, useQuoteMarksInConfigFile: false, inputType: "text", possibleValues: "", notes: ""},
  scoop_slug: {defaultValue: "", includeInSettingsBlock: true, includeInConfigFile: true, useQuoteMarksInConfigFile: false, inputType: "text", possibleValues: "", notes: ""},
  scoop_external_edit_key: {defaultValue: "", includeInSettingsBlock: true, includeInConfigFile: true, useQuoteMarksInConfigFile: false, inputType: "text", possibleValues: "", notes: ""}
};

var defaultBaseSettings = {
  ai2html_environment: {defaultValue: scriptEnvironment, includeInSettingsBlock: false, includeInConfigFile: false, useQuoteMarksInConfigFile: false, inputType: "text", possibleValues: "", notes: ""},
  settings_version: {defaultValue: scriptVersion, includeInSettingsBlock: true, includeInConfigFile: false, useQuoteMarksInConfigFile: false, inputType: "text", possibleValues: "", notes: ""},
  create_promo_image: {defaultValue: "no", includeInSettingsBlock: false, includeInConfigFile: false, useQuoteMarksInConfigFile: false, inputType: "text", possibleValues: "", notes: ""},
  image_format: {defaultValue: ["png"], includeInSettingsBlock: true, includeInConfigFile: false, useQuoteMarksInConfigFile: false, inputType: "array", possibleValues: "jpg, png, png24", notes: "Images will be generated in mulitple formats if multiple formats are listed, separated by commas. The first format will be used in the html. Sometimes this is useful to compare which format will have a smaller file size."},
  write_image_files: {defaultValue: "yes", includeInSettingsBlock: false, includeInConfigFile: false, useQuoteMarksInConfigFile: false, inputType: "yesNo", possibleValues: "", notes: "Set this to \u201Cno\u201D to skip writing the image files. Generally only use this after you have run the script once with this setting set to \u201Cyes.\u201D"},
  responsiveness: {defaultValue: "fixed", includeInSettingsBlock: true, includeInConfigFile: false, useQuoteMarksInConfigFile: false, inputType: "text", possibleValues: "fixed, dynamic", notes: "Dynamic responsiveness means ai graphics will scale to fill the container they are placed in."},
  max_width: {defaultValue: "", includeInSettingsBlock: false, includeInConfigFile: false, useQuoteMarksInConfigFile: false, inputType: "integer", possibleValues: "", notes: "Blank or any positive number in pixels, but do not write \u201Cpx\u201D - blank means artboards will set max size, the max width is not included in the html stub, instead it is written to the config file so that the max width can be applied to the template’s container."},
  output: {defaultValue: "one-file", includeInSettingsBlock: true, includeInConfigFile: false, useQuoteMarksInConfigFile: false, inputType: "text", possibleValues: "one-file, multiple-files", notes: "One html file containing all the artboards or a separate html file for each artboard."},
  project_name: {defaultValue: "", includeInSettingsBlock: false, includeInConfigFile: false, useQuoteMarksInConfigFile: false, inputType: "text", possibleValues: "", notes: "Use this to set a custom project name. The project name is being used in output filenames, class names, etc."},
  html_output_path: {defaultValue: "/ai2html-output/", includeInSettingsBlock: true, includeInConfigFile: false, useQuoteMarksInConfigFile: false, inputType: "folderPath", possibleValues: "", notes: "Allows user to change folder to write html files, path should be written relative to ai file location. This is ignored if the project_type in the yml is ai2html."},
  html_output_extension: {defaultValue: ".html", includeInSettingsBlock: true, includeInConfigFile: false, useQuoteMarksInConfigFile: false, inputType: "fileExtension", possibleValues: "", notes: "This is ignored if the project_type in the yml is ai2html."},
  image_output_path: {defaultValue: "", includeInSettingsBlock: true, includeInConfigFile: false, useQuoteMarksInConfigFile: false, inputType: "folderPath", possibleValues: "", notes: "This is where the image files get written to locally and should be written as if the html_output is the starting point."},
  image_source_path: {defaultValue: null, includeInSettingsBlock: false, includeInConfigFile: false, useQuoteMarksInConfigFile: false, inputType: "folderPath", possibleValues: "", notes: "Use this setting to specify from where the images are being loaded from the HTML file. Defaults to image_output_path"},
  create_config_file: {defaultValue: "false", includeInSettingsBlock: false, includeInConfigFile: false, useQuoteMarksInConfigFile: false, inputType: "trueFalse", possibleValues: "", notes: "This is ignored in env=nyt."},
  config_file_path: {defaultValue: "", includeInSettingsBlock: false, includeInConfigFile: false, useQuoteMarksInConfigFile: false, inputType: "filePath", possibleValues: "", notes: "This only gets used to write the config file. It’s not used in the nyt mode to read the config.yml. Path should written relative to the ai file location."},
  local_preview_template: {defaultValue: "", includeInSettingsBlock: true, includeInConfigFile: false, useQuoteMarksInConfigFile: false, inputType: "filePath", possibleValues: "", notes: ""},
  png_transparent: {defaultValue: "no", includeInSettingsBlock: false, includeInConfigFile: false, useQuoteMarksInConfigFile: false, inputType: "yesNo", possibleValues: "", notes: ""},
  png_number_of_colors: {defaultValue: 128, includeInSettingsBlock: true, includeInConfigFile: false, useQuoteMarksInConfigFile: false, inputType: "integer", possibleValues: "2 to 256", notes: ""},
  jpg_quality: {defaultValue: 60, includeInSettingsBlock: true, includeInConfigFile: false, useQuoteMarksInConfigFile: false, inputType: "integer", possibleValues: "0 to 100", notes: ""},
  center_html_output: {defaultValue: "true", includeInSettingsBlock: false, includeInConfigFile: false, useQuoteMarksInConfigFile: false, inputType: "text", possibleValues: "", notes: "Adds \u201Cmargin:0 auto;\u201D to the div containing the ai2html output."},
  use_2x_images_if_possible: {defaultValue: "yes", includeInSettingsBlock: false, includeInConfigFile: false, useQuoteMarksInConfigFile: false, inputType: "yesNo", possibleValues: "", notes: ""},
  use_lazy_loader: {defaultValue: "no", includeInSettingsBlock: false, includeInConfigFile: false, useQuoteMarksInConfigFile: false, inputType: "yesNo", possibleValues: "", notes: ""},
  include_resizer_css_js: {defaultValue: "no", includeInSettingsBlock: false, includeInConfigFile: false, useQuoteMarksInConfigFile: false, inputType: "yesNo", possibleValues: "", notes: ""},
  include_resizer_classes: {defaultValue: "no", includeInSettingsBlock: false, includeInConfigFile: false, useQuoteMarksInConfigFile: false, inputType: "yesNo", possibleValues: "", notes: ""},
  include_resizer_widths: {defaultValue: "yes", includeInSettingsBlock: false, includeInConfigFile: false, useQuoteMarksInConfigFile: false, inputType: "yesNo", possibleValues: "", notes: "If set to \u201Cyes\u201D, ai2html adds data-min-width and data-max-width attributes to each artboard"},
  include_resizer_script: {defaultValue: "no", includeInSettingsBlock: false, includeInConfigFile: false, useQuoteMarksInConfigFile: false, inputType: "yesNo", possibleValues: "", notes: ""},
  svg_embed_images: {defaultValue: "no", includeInSettingsBlock: false, includeInConfigFile: false, useQuoteMarksInConfigFile: false, inputType: "yesNo", possibleValues: "", notes: ""},
  render_rotated_skewed_text_as: {defaultValue: "html", includeInSettingsBlock: false, includeInConfigFile: false, useQuoteMarksInConfigFile: false, inputType: "text", possibleValues: "image, html", notes: ""},
  show_completion_dialog_box: {defaultValue: "yes", includeInSettingsBlock: false, includeInConfigFile: false, useQuoteMarksInConfigFile: false, inputType: "yesNo", possibleValues: "", notes: "Set this to \u201Cno\u201D if you don't want to see the dialog box confirming completion of the script."},
  clickable_link: {defaultValue: "", includeInSettingsBlock: false, includeInConfigFile: false, useQuoteMarksInConfigFile: false, inputType: "text", possibleValues: "", notes: "If you put a url in this field, an <a> tag will be added, wrapping around the output and pointing to that url."},
  testing_mode: {defaultValue: "no", includeInSettingsBlock: false, includeInConfigFile: false, useQuoteMarksInConfigFile: false, inputType: "yesNo", possibleValues: "", notes: ""},
  last_updated_text: {defaultValue: "", includeInSettingsBlock: false, includeInConfigFile: false, useQuoteMarksInConfigFile: true, inputType: "text", possibleValues: "", notes: ""},
  headline: {defaultValue: "Ai Graphic Headline", includeInSettingsBlock: true, includeInConfigFile: true, useQuoteMarksInConfigFile: true, inputType: "text", possibleValues: "", notes: ""},
  leadin: {defaultValue: "Introductory text here.", includeInSettingsBlock: true, includeInConfigFile: true, useQuoteMarksInConfigFile: true, inputType: "text", possibleValues: "", notes: ""},
  summary: {defaultValue: "", includeInSettingsBlock: false, includeInConfigFile: true, useQuoteMarksInConfigFile: true, inputType: "text", possibleValues: "", notes: "Summary field for Scoop assets"},
  notes: {defaultValue: "Notes: Text goes here.", includeInSettingsBlock: true, includeInConfigFile: true, useQuoteMarksInConfigFile: true, inputType: "text", possibleValues: "", notes: ""},
  sources: {defaultValue: "Source: Name goes here.", includeInSettingsBlock: true, includeInConfigFile: true, useQuoteMarksInConfigFile: true, inputType: "text", possibleValues: "", notes: ""},
  credit: {defaultValue: "By ai2html", includeInSettingsBlock: true, includeInConfigFile: true, useQuoteMarksInConfigFile: true, inputType: "text", possibleValues: "", notes: ""},
  page_template: {defaultValue: "", includeInSettingsBlock: false, includeInConfigFile: false, useQuoteMarksInConfigFile: false, inputType: "text", possibleValues: "", notes: ""},
  publish_system: {defaultValue: "", includeInSettingsBlock: false, includeInConfigFile: false, useQuoteMarksInConfigFile: false, inputType: "text", possibleValues: "", notes: ""},
  environment: {defaultValue: "", includeInSettingsBlock: false, includeInConfigFile: false, useQuoteMarksInConfigFile: false, inputType: "text", possibleValues: "", notes: ""},
  show_in_compatible_apps: {defaultValue: "", includeInSettingsBlock: false, includeInConfigFile: false, useQuoteMarksInConfigFile: true, inputType: "yesNo", possibleValues: "", notes: ""},
  display_for_promotion_only: {defaultValue: "", includeInSettingsBlock: false, includeInConfigFile: false, useQuoteMarksInConfigFile: false, inputType: "trueFalse", possibleValues: "", notes: ""},
  constrain_width_to_text_column: {defaultValue: "", includeInSettingsBlock: false, includeInConfigFile: false, useQuoteMarksInConfigFile: false, inputType: "trueFalse", possibleValues: "", notes: ""},
  scoop_publish_fields: {defaultValue: "", includeInSettingsBlock: false, includeInConfigFile: false, useQuoteMarksInConfigFile: false, inputType: "trueFalse", possibleValues: "", notes: ""},
  scoop_asset_id: {defaultValue: "", includeInSettingsBlock: false, includeInConfigFile: false, useQuoteMarksInConfigFile: false, inputType: "text", possibleValues: "", notes: ""},
  scoop_username: {defaultValue: "", includeInSettingsBlock: false, includeInConfigFile: false, useQuoteMarksInConfigFile: false, inputType: "text", possibleValues: "", notes: ""},
  scoop_slug: {defaultValue: "", includeInSettingsBlock: false, includeInConfigFile: false, useQuoteMarksInConfigFile: false, inputType: "text", possibleValues: "", notes: ""},
  scoop_external_edit_key: {defaultValue: "", includeInSettingsBlock: false, includeInConfigFile: false, useQuoteMarksInConfigFile: false, inputType: "text", possibleValues: "", notes: ""}
};

// End of settings blocks copied from Google Spreadsheet.

// ================================================
// Constant data
// ================================================

// html entity substitution
// not used ==> ["\x22","&quot;"], ["\x3C","&lt;"], ["\x3E","&gt;"], ["\x26","&amp;"],
var htmlCharacterCodes = [["\xA0","&nbsp;"], ["\xA1","&iexcl;"], ["\xA2","&cent;"], ["\xA3","&pound;"], ["\xA4","&curren;"], ["\xA5","&yen;"], ["\xA6","&brvbar;"], ["\xA7","&sect;"], ["\xA8","&uml;"], ["\xA9","&copy;"], ["\xAA","&ordf;"], ["\xAB","&laquo;"], ["\xAC","&not;"], ["\xAD","&shy;"], ["\xAE","&reg;"], ["\xAF","&macr;"], ["\xB0","&deg;"], ["\xB1","&plusmn;"], ["\xB2","&sup2;"], ["\xB3","&sup3;"], ["\xB4","&acute;"], ["\xB5","&micro;"], ["\xB6","&para;"], ["\xB7","&middot;"], ["\xB8","&cedil;"], ["\xB9","&sup1;"], ["\xBA","&ordm;"], ["\xBB","&raquo;"], ["\xBC","&frac14;"], ["\xBD","&frac12;"], ["\xBE","&frac34;"], ["\xBF","&iquest;"], ["\xD7","&times;"], ["\xF7","&divide;"], ["\u0192","&fnof;"], ["\u02C6","&circ;"], ["\u02DC","&tilde;"], ["\u2002","&ensp;"], ["\u2003","&emsp;"], ["\u2009","&thinsp;"], ["\u200C","&zwnj;"], ["\u200D","&zwj;"], ["\u200E","&lrm;"], ["\u200F","&rlm;"], ["\u2013","&ndash;"], ["\u2014","&mdash;"], ["\u2018","&lsquo;"], ["\u2019","&rsquo;"], ["\u201A","&sbquo;"], ["\u201C","&ldquo;"], ["\u201D","&rdquo;"], ["\u201E","&bdquo;"], ["\u2020","&dagger;"], ["\u2021","&Dagger;"], ["\u2022","&bull;"], ["\u2026","&hellip;"], ["\u2030","&permil;"], ["\u2032","&prime;"], ["\u2033","&Prime;"], ["\u2039","&lsaquo;"], ["\u203A","&rsaquo;"], ["\u203E","&oline;"], ["\u2044","&frasl;"], ["\u20AC","&euro;"], ["\u2111","&image;"], ["\u2113",""], ["\u2116",""], ["\u2118","&weierp;"], ["\u211C","&real;"], ["\u2122","&trade;"], ["\u2135","&alefsym;"], ["\u2190","&larr;"], ["\u2191","&uarr;"], ["\u2192","&rarr;"], ["\u2193","&darr;"], ["\u2194","&harr;"], ["\u21B5","&crarr;"], ["\u21D0","&lArr;"], ["\u21D1","&uArr;"], ["\u21D2","&rArr;"], ["\u21D3","&dArr;"], ["\u21D4","&hArr;"], ["\u2200","&forall;"], ["\u2202","&part;"], ["\u2203","&exist;"], ["\u2205","&empty;"], ["\u2207","&nabla;"], ["\u2208","&isin;"], ["\u2209","&notin;"], ["\u220B","&ni;"], ["\u220F","&prod;"], ["\u2211","&sum;"], ["\u2212","&minus;"], ["\u2217","&lowast;"], ["\u221A","&radic;"], ["\u221D","&prop;"], ["\u221E","&infin;"], ["\u2220","&ang;"], ["\u2227","&and;"], ["\u2228","&or;"], ["\u2229","&cap;"], ["\u222A","&cup;"], ["\u222B","&int;"], ["\u2234","&there4;"], ["\u223C","&sim;"], ["\u2245","&cong;"], ["\u2248","&asymp;"], ["\u2260","&ne;"], ["\u2261","&equiv;"], ["\u2264","&le;"], ["\u2265","&ge;"], ["\u2282","&sub;"], ["\u2283","&sup;"], ["\u2284","&nsub;"], ["\u2286","&sube;"], ["\u2287","&supe;"], ["\u2295","&oplus;"], ["\u2297","&otimes;"], ["\u22A5","&perp;"], ["\u22C5","&sdot;"], ["\u2308","&lceil;"], ["\u2309","&rceil;"], ["\u230A","&lfloor;"], ["\u230B","&rfloor;"], ["\u2329","&lang;"], ["\u232A","&rang;"], ["\u25CA","&loz;"], ["\u2660","&spades;"], ["\u2663","&clubs;"], ["\u2665","&hearts;"], ["\u2666","&diams;"]];

// Add to the fonts array to make the script work with your own custom fonts.
// To make it easier to add to this array, use the "fonts" worksheet of this Google Spreadsheet:
  // https://docs.google.com/spreadsheets/d/13ESQ9ktfkdzFq78FkWLGaZr2s3lNbv2cN25F2pYf5XM/edit?usp=sharing
  // Make a copy of the spreadsheet for yourself.
  // Modify the settings to taste.
var fonts = [
  {"aifont":"ArialMT","family":"arial,helvetica,sans-serif","weight":"","style":""},
  {"aifont":"Arial-BoldMT","family":"arial,helvetica,sans-serif","weight":"bold","style":""},
  {"aifont":"Arial-ItalicMT","family":"arial,helvetica,sans-serif","weight":"","style":"italic"},
  {"aifont":"Arial-BoldItalicMT","family":"arial,helvetica,sans-serif","weight":"bold","style":"italic"},
  {"aifont":"Georgia","family":"georgia,'times new roman',times,serif","weight":"","style":""},
  {"aifont":"Georgia-Bold","family":"georgia,'times new roman',times,serif","weight":"bold","style":""},
  {"aifont":"Georgia-Italic","family":"georgia,'times new roman',times,serif","weight":"","style":"italic"},
  {"aifont":"Georgia-BoldItalic","family":"georgia,'times new roman',times,serif","weight":"bold","style":"italic"},
  {"aifont":"NYTFranklin-Light","family":"nyt-franklin,arial,helvetica,sans-serif","weight":"300","style":""},
  {"aifont":"NYTFranklin-Medium","family":"nyt-franklin,arial,helvetica,sans-serif","weight":"500","style":""},
  {"aifont":"NYTFranklin-SemiBold","family":"nyt-franklin,arial,helvetica,sans-serif","weight":"600","style":""},
  {"aifont":"NYTFranklinSemiBold-Regular","family":"nyt-franklin,arial,helvetica,sans-serif","weight":"600","style":""},
  {"aifont":"NYTFranklin-Bold","family":"nyt-franklin,arial,helvetica,sans-serif","weight":"700","style":""},
  {"aifont":"NYTFranklin-LightItalic","family":"nyt-franklin,arial,helvetica,sans-serif","weight":"300","style":"italic"},
  {"aifont":"NYTFranklin-MediumItalic","family":"nyt-franklin,arial,helvetica,sans-serif","weight":"500","style":"italic"},
  {"aifont":"NYTFranklin-BoldItalic","family":"nyt-franklin,arial,helvetica,sans-serif","weight":"700","style":"italic"},
  {"aifont":"NYTFranklin-Headline","family":"nyt-franklin,arial,helvetica,sans-serif","weight":"bold","style":""},
  {"aifont":"NYTFranklin-HeadlineItalic","family":"nyt-franklin,arial,helvetica,sans-serif","weight":"bold","style":"italic"},
  {"aifont":"NYTCheltenham-ExtraLight","family":"nyt-cheltenham,georgia,'times new roman',times,serif","weight":"200","style":""},
  {"aifont":"NYTCheltenhamExtLt-Regular","family":"nyt-cheltenham,georgia,'times new roman',times,serif","weight":"200","style":""},
  {"aifont":"NYTCheltenham-Light","family":"nyt-cheltenham,georgia,'times new roman',times,serif","weight":"300","style":""},
  {"aifont":"NYTCheltenhamLt-Regular","family":"nyt-cheltenham,georgia,'times new roman',times,serif","weight":"300","style":""},
  {"aifont":"NYTCheltenham-Book","family":"nyt-cheltenham,georgia,'times new roman',times,serif","weight":"400","style":""},
  {"aifont":"NYTCheltenhamBook-Regular","family":"nyt-cheltenham,georgia,'times new roman',times,serif","weight":"400","style":""},
  {"aifont":"NYTCheltenham-Wide","family":"nyt-cheltenham,georgia,'times new roman',times,serif","weight":"","style":""},
  {"aifont":"NYTCheltenhamMedium-Regular","family":"nyt-cheltenham,georgia,'times new roman',times,serif","weight":"500","style":""},
  {"aifont":"NYTCheltenham-Medium","family":"nyt-cheltenham,georgia,'times new roman',times,serif","weight":"500","style":""},
  {"aifont":"NYTCheltenham-Bold","family":"nyt-cheltenham,georgia,'times new roman',times,serif","weight":"700","style":""},
  {"aifont":"NYTCheltenham-BoldCond","family":"nyt-cheltenham,georgia,'times new roman',times,serif","weight":"bold","style":""},
  {"aifont":"NYTCheltenham-BoldExtraCond","family":"nyt-cheltenham,georgia,'times new roman',times,serif","weight":"bold","style":""},
  {"aifont":"NYTCheltenham-ExtraBold","family":"nyt-cheltenham,georgia,'times new roman',times,serif","weight":"bold","style":""},
  {"aifont":"NYTCheltenham-ExtraLightIt","family":"nyt-cheltenham,georgia,'times new roman',times,serif","weight":"","style":"italic"},
  {"aifont":"NYTCheltenham-ExtraLightItal","family":"nyt-cheltenham,georgia,'times new roman',times,serif","weight":"","style":"italic"},
  {"aifont":"NYTCheltenham-LightItalic","family":"nyt-cheltenham,georgia,'times new roman',times,serif","weight":"","style":"italic"},
  {"aifont":"NYTCheltenham-BookItalic","family":"nyt-cheltenham,georgia,'times new roman',times,serif","weight":"","style":"italic"},
  {"aifont":"NYTCheltenham-WideItalic","family":"nyt-cheltenham,georgia,'times new roman',times,serif","weight":"","style":"italic"},
  {"aifont":"NYTCheltenham-MediumItalic","family":"nyt-cheltenham,georgia,'times new roman',times,serif","weight":"","style":"italic"},
  {"aifont":"NYTCheltenham-BoldItalic","family":"nyt-cheltenham,georgia,'times new roman',times,serif","weight":"700","style":"italic"},
  {"aifont":"NYTCheltenham-ExtraBoldItal","family":"nyt-cheltenham,georgia,'times new roman',times,serif","weight":"bold","style":"italic"},
  {"aifont":"NYTCheltenham-ExtraBoldItalic","family":"nyt-cheltenham,georgia,'times new roman',times,serif","weight":"bold","style":"italic"},
  {"aifont":"NYTKarnakText-Regular","family":"nyt-karnak-display-130124,georgia,'times new roman',times,serif","weight":"400","style":""},
  {"aifont":"NYTKarnakDisplay-Regular","family":"nyt-karnak-display-130124,georgia,'times new roman',times,serif","weight":"400","style":""},
  {"aifont":"NYTStymieLight-Regular","family":"nyt-stymie,arial,helvetica,sans-serif","weight":"300","style":""},
  {"aifont":"NYTStymieMedium-Regular","family":"nyt-stymie,arial,helvetica,sans-serif","weight":"500","style":""},
  {"aifont":"StymieNYT-Light","family":"nyt-stymie,arial,helvetica,sans-serif","weight":"300","style":""},
  {"aifont":"StymieNYT-LightPhoenetic","family":"nyt-stymie,arial,helvetica,sans-serif","weight":"300","style":""},
  {"aifont":"StymieNYT-Lightitalic","family":"nyt-stymie,arial,helvetica,sans-serif","weight":"300","style":"italic"},
  {"aifont":"StymieNYT-Medium","family":"nyt-stymie,arial,helvetica,sans-serif","weight":"500","style":""},
  {"aifont":"StymieNYT-MediumItalic","family":"nyt-stymie,arial,helvetica,sans-serif","weight":"500","style":"italic"},
  {"aifont":"StymieNYT-Bold","family":"nyt-stymie,arial,helvetica,sans-serif","weight":"700","style":""},
  {"aifont":"StymieNYT-BoldItalic","family":"nyt-stymie,arial,helvetica,sans-serif","weight":"700","style":"italic"},
  {"aifont":"StymieNYT-ExtraBold","family":"nyt-stymie,arial,helvetica,sans-serif","weight":"700","style":""},
  {"aifont":"StymieNYT-ExtraBoldText","family":"nyt-stymie,arial,helvetica,sans-serif","weight":"700","style":""},
  {"aifont":"StymieNYT-ExtraBoldTextItal","family":"nyt-stymie,arial,helvetica,sans-serif","weight":"700","style":"italic"},
  {"aifont":"StymieNYTBlack-Regular","family":"nyt-stymie,arial,helvetica,sans-serif","weight":"700","style":""},
  {"aifont":"StymieBT-ExtraBold","family":"nyt-stymie,arial,helvetica,sans-serif","weight":"700","style":""},
  {"aifont":"Stymie-Thin","family":"nyt-stymie,arial,helvetica,sans-serif","weight":"300","style":""},
  {"aifont":"Stymie-UltraLight","family":"nyt-stymie,arial,helvetica,sans-serif","weight":"300","style":""},
  {"aifont":"NYTMagSans-Regular","family":"'nyt-mag-sans',arial,helvetica,sans-serif","weight":"500","style":""},
  {"aifont":"NYTMagSans-Bold","family":"'nyt-mag-sans',arial,helvetica,sans-serif","weight":"700","style":""}
];

var caps = [
  {"ai":"FontCapsOption.NORMALCAPS","html":""},
  {"ai":"FontCapsOption.ALLCAPS","html":"uppercase"},
  {"ai":"FontCapsOption.SMALLCAPS","html":"uppercase"}
];

var align = [
  {"ai":"Justification.LEFT","html":"left"},
  {"ai":"Justification.RIGHT","html":"right"},
  {"ai":"Justification.CENTER","html":"center"},
  {"ai":"Justification.FULLJUSTIFY","html":"justify"},
  {"ai":"Justification.FULLJUSTIFYLASTLINELEFT","html":"justify"},
  {"ai":"Justification.FULLJUSTIFYLASTLINECENTER","html":"justify"},
  {"ai":"Justification.FULLJUSTIFYLASTLINERIGHT","html":"justify"}
];

var textStyleKeys = [
  "aifont",
  "size",
  "capitalization",
  "color",
  "tracking",
  "leading",
  "spaceBefore",
  "spaceAfter",
  "justification",
  "opacity"
];

var nyt5Breakpoints = [
  { name:"xsmall"    , lowerLimit:   0, upperLimit: 180 },
  { name:"small"     , lowerLimit: 180, upperLimit: 300 },
  { name:"smallplus" , lowerLimit: 300, upperLimit: 460 },
  { name:"submedium" , lowerLimit: 460, upperLimit: 600 },
  { name:"medium"    , lowerLimit: 600, upperLimit: 720 },
  { name:"large"     , lowerLimit: 720, upperLimit: 945 },
  { name:"xlarge"    , lowerLimit: 945, upperLimit:1050 },
  { name:"xxlarge"   , lowerLimit:1050, upperLimit:1600 }
];

var nameSpace           = "g-";
var cssPrecision        = 4;
// value between 0 and 255 lower than which if all three RGB values are below
// then force the RGB to #000 so it is a pure black
var rgbBlackThreshold  = 36;
var showDebugMessages  = true; // add text logged with message() function to completion alert

// ================================
// Variable declarations
// ================================

// vars to hold warnings and informational messages at the end
var feedback = [];
var warnings = [];
var errors   = [];
var unknownFonts = [];
var htmlTags = [];
var textFramesToUnhide = [];
var objectsToRelock = [];

// Global variables set by main()
var docSettings = {};
var ai2htmlBaseSettings;
var previewProjectType, scriptEnvironment;
var doc, docPath, docName, docIsSaved;
var pBar, T;

// include JSON
// @include "lib/json2.js"

// ===========================================================
// In AI context: run script. In Node: export functions for testing
// ===========================================================

var jsEnvironment = typeof module === "object" && module.exports ? "node" : "ai";
if (jsEnvironment == 'ai') {
  main();
}
if (jsEnvironment == 'node') {
  // export functions for testing
  // TODO: write more tests
  [ testBoundsIntersection,
    trim,
    contains,
    arraySubtract,
    firstBy,
    zeroPad,
    roundTo,
    folderExists,
    formatCss,
    getCssColor,
    readGitConfigFile,
    readYamlConfigFile,
    applyTemplate,
    cleanText,
    findHtmlTag
  ].forEach(function(f) {
    module.exports[f.name] = f;
  });
}


// =================================
// Main function
// =================================

function main() {

  // Performance timing using T.start() and T.stop("message")
  T = {
    stack: [],
    start: function() {
      T.stack.push(+new Date());
    },
    stop: function(note) {
      message((+new Date() - T.stack.pop()) + 'ms - ' + note);
    }
  };

  T.start();

  if (!app.documents.length) {
    errors.push("No documents are open");

  } else if (!String(app.activeDocument.path)) {
    errors.push('You need to save your Illustrator file before running this script');

  } else if (app.activeDocument.documentColorSpace!="DocumentColorSpace.RGB") {
    errors.push('Convert document color mode to "RGB" before running script. (File>Document Color Mode>RGB Color)' );

  } else {
    doc = app.activeDocument;
    docPath = doc.path + "/";
    docIsSaved = doc.saved;
    pBar = new ProgressBar({name: "Ai2html progress", steps: calcProgressBarSteps()});

    try {
      render();
    } catch(e) {
      errors.push(formatError(e));
    }
    restoreDocumentState();
  }


  // ==========================================
  // Save the AI document (if needed)
  // ==========================================

  if (docIsSaved) {
    // If document was originally in a saved state, reset the document's
    // saved flag (the document goes to unsaved state during the script,
    // because of unlocking / relocking of objects
    doc.saved = true;
  } else if (errors.length === 0) {
    // Auto-save the document if no errors occurred
    var saveOptions = new IllustratorSaveOptions();
    saveOptions.pdfCompatible = false;
    pBar.setTitle('Saving Illustrator document...');
    T.start();
    doc.saveAs(new File(docPath + doc.name), saveOptions);
    T.stop("Saved document " + doc.name);
    feedback.push("Your Illustrator file was saved.");
  }

  if (pBar) pBar.close();
  T.stop("Total time");

  // =========================================================
  // Show alert box, optionally prompt to generate promo image
  // =========================================================

  if (isTrue(docSettings.show_completion_dialog_box ) || errors.length > 0) {
    var promptForPromo = errors.length === 0 &&
      isTrue(docSettings.write_image_files) &&
      (previewProjectType == "ai2html" || isTrue(docSettings.create_promo_image));
    var showPromo = showCompletionAlert(promptForPromo);
    if (showPromo) createPromoImage(docSettings);
  }
} // end main()

// =================================
// ai2html render function
// =================================

function render() {
  // detect ai2html environment
  if (folderExists(docPath + "../public/_assets")) {
    // Use "nyt" environment if it looks like the document is in a Preview project
    ai2htmlBaseSettings = nytBaseSettings;
    scriptEnvironment = "nyt";
  } else {
    ai2htmlBaseSettings = defaultBaseSettings;
    scriptEnvironment = "";
  }

  // initialize document settings
  // TODO: remove obsolete option: ai2html_environment
  for (var setting in ai2htmlBaseSettings) {
    docSettings[setting] = ai2htmlBaseSettings[setting].defaultValue;
  }

  // Fix for issue #50
  // If a text range is selected when the script runs, it interferes
  // with script-driven selection. The fix is to clear this kind of selection.
  if (doc.selection && doc.selection.typename) {
    clearSelection();
  }

  // Unlock containers and clipping masks
  unlockObjects();

  // ================================================
  // assign artboards to their corresponding breakpoints
  // ================================================
  // (can have more than one artboard per breakpoint.)

  // TODO: seems to assume NYT5 environment -- check that it works outside NYT
  var breakpoints = assignBreakpointsToArtboards(nyt5Breakpoints);

  // ================================================
  // grab custom settings, html, css, js and text blocks
  // ================================================
  var documentHasSettingsBlock = false;
  var customBlocks = {};

  forEach(doc.textFrames, function(thisFrame) {
    var firstLine = thisFrame.lines.length > 1 ? thisFrame.lines[0].contents : '';
    var match = /^ai2html-(css|js|html|settings|text)$/.exec(firstLine);
    var type = match ? match[1] : null;
    var content = "";
    if (type) {
      hideTextFrame(thisFrame);
      if (type == 'settings') {
        documentHasSettingsBlock = true;
        parseSettingsTextBlock(thisFrame, docSettings);
      } else if (type == 'text') {
        parseSettingsTextBlock(thisFrame, docSettings);
      } else { // custom js, css and html
        for (var i=1, n=thisFrame.paragraphs.length; i<n; i++) {
          try {
            content += "\t\t" + cleanText(thisFrame.paragraphs[i].contents) + "\r";
          } catch(e) {}
        }
        if (!customBlocks[type]) {
          customBlocks[type] = [];
        }
        customBlocks[type].push(content);
      }
    }
  });

  if (customBlocks.css)  {feedback.push("Custom CSS blocks: " + customBlocks.css.length);}
  if (customBlocks.html) {feedback.push("Custom HTML blocks: " + customBlocks.html.length);}
  if (customBlocks.js)   {feedback.push("Custom JS blocks: " + customBlocks.js.length);}

  // ================================================
  // add settings text block if one does not exist
  // ================================================

  if (!documentHasSettingsBlock) {
    createSettingsBlock();
    if (scriptEnvironment=="nyt") {
      feedback.push("A settings text block was created to the left of all your artboards. Fill out the settings to link your project to the Scoop asset.");
      return; // Exit the script
    } else {
      feedback.push("A settings text block was created to the left of all your artboards. You can use it to customize your output.");
    }
  }


  // ================================================
  // initialization for NYT environment
  // ================================================

  if (scriptEnvironment == "nyt") {

    // Read yml file if it exists to determine what type of project this is
    //
    var yaml = readYamlConfigFile(docPath + "../config.yml");
    if (!yaml) {
      previewProjectType = "config.yml is missing";
    } else {
      if (yaml.project_type == 'ai2html') {
        previewProjectType = 'ai2html';
      }
      if (yaml.scoop_slug) {
        docSettings.scoop_slug_from_config_yml = yaml.scoop_slug;
      }
    }

    if (previewProjectType=="config.yml is missing" ||
        (previewProjectType=="ai2html" && !folderExists(docPath + "../public/")) ||
        (previewProjectType!="ai2html" && !folderExists(docPath + "../src/"))) {
      errors.push("Make sure your Illustrator file is inside the \u201Cai\u201D folder of a Preview project.");
      errors.push("If the Illustrator file is in the correct folder, your Preview project may be missing a config.yml file or a \u201Cpublic\u201D or a \u201Csrc\u201D folder.");
      errors.push("If this is an ai2html project, it is probably easier to just create a new ai2html Preview project and move this Illustrator file into the \u201Cai\u201D folder inside the project.");
      return;
    }

    // Read .git/config file to get preview slug
    var gitConfig = readGitConfigFile(docPath + "../.git/config") || {};
    if (gitConfig.url) {
      docSettings.preview_slug = gitConfig.url.replace( /^[^:]+:/ , "" ).replace( /\.git$/ , "");
    }

    docSettings.image_source_path = "_assets/";

    if (previewProjectType=="ai2html") {
      docSettings.html_output_path      = "/../public/";
      docSettings.html_output_extension = ".html";
      docSettings.image_output_path     = "_assets/";
    }

    if (docSettings.max_width && !contains(breakpoints, function(bp) {
      return +docSettings.max_width == bp.upperLimit;
    })) {
      warnings.push('The max_width setting of "' + docSettings.max_width +
        '" is not a valid breakpoint and will create an error when you "preview publish."');
    }
  }


  // ================================================
  // initialization for all environments
  // ================================================

  docName = docSettings.project_name || doc.name.replace(/(.+)\.[aieps]+$/,"$1").replace(/ +/g,"-");
  docName = makeKeyword(docName);

  if (docSettings.image_source_path === null) {
    docSettings.image_source_path = docSettings.image_output_path;
  }

  if (docSettings.image_format.length === 0) {
    warnings.push("No images were created because no image formats were specified.");
  }


  // ================================================
  // Generate HTML, CSS and images for each artboard
  // ================================================

  var artboardContent = "";
  var masks = findMasks(); // identify all clipping masks and their contents

  forEachUsableArtboard(function(activeArtboard, abNumber) {
    var docArtboardName  = getArtboardFullName(activeArtboard);
    doc.artboards.setActiveArtboardIndex(abNumber);

    T.start();

    // ========================
    // Convert text objects
    // ========================
    T.start();
    pBar.setTitle(docArtboardName + ': Generating text...');

    var textFrames = getTextFramesByArtboard(activeArtboard, masks);
    var textData = convertTextFrames(textFrames, activeArtboard);

    pBar.step();
    T.stop("Text generation");

    // ==========================
    // generate artboard image(s)
    // ==========================

    if (docSettings.write_image_files=="yes") {
      pBar.setTitle(docArtboardName + ': Capturing image...');
      T.start();
      captureArtboardImage(activeArtboard, textFrames, masks, docSettings);
      T.stop("Image generation");
    }
    pBar.step();

    //=====================================
    // finish generating artboard HTML and CSS
    //=====================================

    artboardContent +=
      "\r\t<!-- Artboard: " + getArtboardName(activeArtboard) + " -->\r" +
      generateArtboardDiv(activeArtboard, breakpoints, docSettings) +
      generateArtboardCss(activeArtboard, textData.styles, docSettings) +
      generateImageHtml(activeArtboard, docSettings) +
      textData.html +
      "\t</div>\r";

    //=====================================
    // output html file here if doing a file for every artboard
    //=====================================

    if (docSettings.output=="multiple-files") {
      generateOutputHtml(addCustomContent(artboardContent, customBlocks), docArtboardName, docSettings);
      artboardContent = "";
    }
    T.stop("Total for artboard " + (activeArtboard.name || abNumber));

  }); // end artboard loop

  //=====================================
  // output html file here if doing one file for all artboards
  //=====================================

  if (docSettings.output=="one-file") {
    generateOutputHtml(addCustomContent(artboardContent, customBlocks), docName, docSettings);
  }

  //=====================================
  // write configuration file with graphic metadata
  //=====================================

  if ((scriptEnvironment=="nyt" && previewProjectType=="ai2html") ||
      (scriptEnvironment!="nyt" && isTrue(docSettings.create_config_file))) {
    var yamlPath = docPath + docSettings.config_file_path,
        yamlStr = generateYmlFileContent(breakpoints, docSettings);
    checkForOutputFolder(yamlPath.replace(/[^\/]+$/, ""), "configFileFolder");
    saveTextFile(yamlPath, yamlStr);
  }
} // end render()


// =================================
// JS utility functions
// =================================

function forEach(arr, cb) {
  for (var i=0, n=arr.length; i<n; i++) {
    cb(arr[i], i);
  }
}

function map(arr, cb) {
  var arr2 = [];
  for (var i=0, n=arr.length; i<n; i++) {
    arr2.push(cb(arr[i], i));
  }
  return arr2;
}

function filter(arr, test) {
  var filtered = [];
  for (var i=0, n=arr.length; i<n; i++) {
    if (test(arr[i], i)) {
      filtered.push(arr[i]);
    }
  }
  return filtered;
}

// obj: value or test function
function indexOf(arr, obj) {
  var test = typeof obj == 'function' ? obj : null;
  for (var i=0, n=arr.length; i<n; i++) {
    if (test ? test(arr[i]) : arr[i] === obj) {
      return i;
    }
  }
  return -1;
}

function find(arr, obj) {
  var i = indexOf(arr, obj);
  return i == -1 ? null : arr[i];
}

function contains(arr, obj) {
  return indexOf(arr, obj) >= 0;
}

function extend(o) {
  for (var i=1; i<arguments.length; i++) {
    forEachProperty(arguments[i], add);
  }
  function add(v, k) {
    o[k] = v;
  }
  return o;
}

function forEachProperty(o, cb) {
  for (var k in o) {
    if (o.hasOwnProperty(k)) {
      cb(o[k], k);
    }
  }
}

// return styles that are in a but not b
// a, b: style objects
// properties: array of properties to consider
function objectSubtract(a, b) {
  var diff = null;
  for (var k in a) {
    if (a[k] != b[k] && a.hasOwnProperty(k)) {
      diff = diff || {};
      diff[k] = a[k];
    }
  }
  return diff;
}

// return elements in array "a" but not in array "b"
function arraySubtract(a, b) {
  var diff = [],
      alen = a.length,
      blen = b.length,
      i, j;
  for (i=0; i<alen; i++) {
    diff.push(a[i]);
    for (j=0; j<blen; j++) {
      if (a[i] === b[j]) {
        diff.pop();
        break;
      }
    }
  }
  return diff;
}

// Copy elements of an array-like object to an array
function toArray(obj) {
  var arr = [];
  for (var i=0, n=obj.length; i<n; i++) {
    arr[i] = obj[i];
  }
  return arr;
}

// multiple key sorting function based on https://github.com/Teun/thenBy.js
// first by length of name, then by population, then by ID
// data.sort(
//     firstBy(function (v1, v2) { return v1.name.length - v2.name.length; })
//     .thenBy(function (v1, v2) { return v1.population - v2.population; })
//     .thenBy(function (v1, v2) { return v1.id - v2.id; });
// );
function firstBy(f1, f2) {
  var compare = f2 ? function(a, b) {return f1(a, b) || f2(a, b);} : f1;
  compare.thenBy = function(f) {return firstBy(compare, f);};
  return compare;
}

function keys(obj) {
  var keys = [];
  for (var k in obj) {
    keys.push(k);
  }
  return keys;
}

// Remove whitespace from beginning and end of a string
function trim(s) {
  return s.replace(/^[\s\uFEFF\xA0]+|[\s\uFEFF\xA0]+$/g, '');
}

function zeroPad(val, digits) {
  var str = String(val);
  while (str.length < digits) str = '0' + str;
  return str;
}

function makeKeyword(text) {
  return text.replace( /[^A-Za-z0-9_\-]+/g , "_" );
}

function cleanText(text) {
  for (var i=0; i < htmlCharacterCodes.length; i++) {
    var charCode = htmlCharacterCodes[i];
    if (text.indexOf(charCode[0]) > -1) {
      text = text.replace(new RegExp(charCode[0],'g'), charCode[1]);
    }
  }
  return text;
}

function straightenCurlyQuotesInsideAngleBrackets(text) {
  // thanks to jashkenas
  var tagFinder = /<[^\n]+?>/g;
  var quoteFinder = /[\u201C‘’\u201D]([^\n]*?)[\u201C‘’\u201D]/g;
  return text.replace(tagFinder, function(tag){
    return tag.replace( /[\u201C\u201D]/g , '"' ).replace( /[‘’]/g , "'" );
  });
}

// Not very robust -- good enough for printing a warning
function findHtmlTag(str) {
  var match;
  if (str.indexOf('<') > -1) { // bypass regex check
    match = /<(\w+)[^>]*>/.exec(str);
  }
  return match ? match[1] : null;
}

// precision: number of decimals in rounded number
function roundTo(number, precision) {
  var d = Math.pow(10, precision || 0);
  return Math.round(number * d) / d;
}

// TODO: value could change during program execution -- does this matter?
function getDateTimeStamp() {
  var d     = new Date();
  var year  = d.getFullYear();
  var date  = zeroPad(d.getDate(),2);
  var month = zeroPad(d.getMonth() + 1,2);
  var hour  = zeroPad(d.getHours(),2);
  var min   = zeroPad(d.getMinutes(),2);
  return year + "-" + month + "-" + date + " - " + hour + ":" + min;
}

// obj: JS object containing css properties and values
// indentStr: string to use as block CSS indentation
function formatCss(obj, indentStr) {
  var css = '';
  var isBlock = !!indentStr;
  for (var key in obj) {
    if (isBlock) {
      css += '\r' + indentStr;
    }
    css += key + ':' + obj[key]+ ';';
  }
  if (css && isBlock) {
    css += '\r';
  }
  return css;
}

function getCssColor(r, g, b) {
  return 'rgb(' + r + ',' + g + ',' + b + ')';
}

function testSimilarBounds(a, b, maxOffs) {
  if (maxOffs >= 0 === false) maxOffs = 1;
  for (var i=0; i<4; i++) {
    if (Math.abs(a[i] - b[i]) > maxOffs) return false;
  }
  return true;
}

// Apply very basic string substitution to a template
function applyTemplate(template, atObject) {
  var keyExp = '([_a-zA-Z]\\w*)';
  var mustachePattern = new RegExp("\\{\\{\\{? *" + keyExp + " *\\}\\}\\}?","g");
  var ejsPattern = new RegExp("<%=? *" + keyExp + " *%>","g");
  var replace = function(match, key) {
    return (key in atObject) ? atObject[key] : match;
  };
  return template.replace(mustachePattern, replace).replace(ejsPattern, replace);
}

// =====================================
// Illustrator specific utility functions
// =====================================

function folderExists(path) {
  return new Folder(path).exists;
}

// Very simple Yaml parsing. Does not implement nested properties and other features
function readYamlConfigFile(path) {
  var file = new File(path);
  var dqRxp = /^"(?:[^"\\]|\\.)*"$/;
  var o = null;
  var parts, k, v;
  if (file.exists) {
    o = {};
    file.open("r");
    while(!file.eof) {
      parts = file.readln().split(':');
      if (parts.length > 1) {
        k = trim(parts.shift());
        v = trim(parts.join(':'));
        if (dqRxp.test(v)) {
          v = JSON.parse(v); // use JSON library to parse quoted strings
        }
        o[k] = v;
      }
    }
    file.close();
  }
  return o;
}

// TODO: improve
// (currently ignores bracketed sections of the config file)
function readGitConfigFile(path) {
  var file = new File(path);
  var o = null;
  var parts;
  if (file.exists) {
    o = {};
    file.open("r");
    while(!file.eof) {
      parts = file.readln().split("=");
      if (parts.length > 1) {
        o[trim(parts[0])] = trim(parts[1]);
      }
    }
    file.close();
  }
  return o;
}

function getRGBColor(r,g,b) {
  var col = new RGBColor();
  col.red = r || 0;
  col.green = g || 0;
  col.blue = b || 0;
  return col;
}

function readTextFile(path) {
  var outputText = "";
  var file = new File(path);
  if (file.exists) {
    file.open("r");
    while (!file.eof) {
      outputText += file.readln() + "\n";
    }
    file.close();
  } else {
    warnings.push(path + " could not be found.");
  }
  return outputText;
}

function saveTextFile(dest, contents) {
  var fd = new File(dest);
  fd.open("w", "TEXT", "TEXT");
  fd.lineFeed = "Unix";
  fd.encoding = "UTF-8";
  fd.writeln(contents);
  fd.close();
}

// a, b: coordinate arrays, as from <PathItem>.geometricBounds
function testBoundsIntersection(a, b) {
  return a[2] >= b[0] && b[2] >= a[0] && a[3] <= b[1] && b[3] <= a[1];
}

function objectIsHidden(obj) {
  var hidden = false;
  while (!hidden && obj && obj.typename != "Document"){
    if (obj.typename == "Layer") {
      hidden = !obj.visible;
    } else {
      hidden = obj.hidden;
    }
    obj = obj.parent;
  }
  return hidden;
}

function getComputedOpacity(obj) {
  var opacity = 1;
  while (obj && obj.typename != "Document") {
    opacity *= obj.opacity / 100;
    obj = obj.parent;
  }
  return opacity * 100;
}

function ProgressBar(opts) {
  opts = opts || {};
  var steps = opts.steps || 0;
  var step = 0;
  var win = new Window("palette", opts.name || "Progress", [150, 150, 600, 260]);
  win.pnl = win.add("panel", [10, 10, 440, 100], "Progress");
  win.pnl.progBar      = win.pnl.add("progressbar", [20, 35, 410, 60], 0, 100);
  win.pnl.progBarLabel = win.pnl.add("statictext", [20, 20, 320, 35], "0%");
  win.show();

  function getProgress() {
    return win.pnl.progBar.value/win.pnl.progBar.maxvalue;
  }

  function update() {
    win.update();
  }

  this.step = function() {
    step = Math.min(step + 1, steps);
    this.setProgress(step / steps);
  };

  this.setProgress = function(progress) {
    var max = win.pnl.progBar.maxvalue;
    // progress is always 0.0 to 1.0
    var pct = progress * max;
    win.pnl.progBar.value = pct;
    win.pnl.progBarLabel.text = Math.round(pct) + "%";
    update();
  };

  this.setTitle = function(title) {
    win.pnl.text = title;
    update();
  };

  this.close = function() {
    win.close();
  };
}


// =====================================
// ai2html specific utility functions
// =====================================

function calcProgressBarSteps() {
  var n = 0;
  forEachUsableArtboard(function() {
    n += 2;
  });
  return n;
}

function formatError(e) {
  var msg = "Runtime error";
  if (e.line) msg += " on line " + e.line;
  if (e.message) msg += ": " + e.message;
  return msg;
}

// display debugging message in completion alert box
// (in debug mode)
function message() {
  var msg = "", arg;
  for (var i=0; i<arguments.length; i++) {
    arg = arguments[i];
    if (msg.length > 0) msg += ' ';
    if (typeof arg == 'object') {
      try {
        // json2.json implementation throws error if object contains a cycle
        // and many Illustrator objects have cycles.
        msg += JSON.stringify(arg);
      } catch(e) {
        msg += String(arg);
      }
    } else {
      msg += arg;
    }
  }
  if (showDebugMessages) feedback.push(msg);
}


// accept inconsistent true/yes setting value
function isTrue(val) {
  return val == "true" || val == "yes" || val === true;
}

function isFalse(val) {
  return val == "false" || val == "no" || val === false;
}

function unlockObjects() {
  forEach(doc.layers, unlockContainer);
}

function unlockObject(obj) {
  obj.locked = false;
  objectsToRelock.push(obj);
}

// Unlock a layer or group if visible and locked, as well as any locked and visible
//   clipping masks
// o: GroupItem or Layer
function unlockContainer(o) {
  var type = o.typename;
  var i, item, pathCount;
  if (o.hidden === true || o.visible === false) return;
  if (o.locked) {
    unlockObject(o);
  }

  // unlock locked clipping paths (so contents can be selected later)
  // optimization: Layers containing hundreds or thousands of paths are unlikely
  //    to contain a clipping mask and are slow to scan -- skip these
  pathCount = o.pathItems.length;
  if ((type == 'Layer' && pathCount < 500) || (type == 'GroupItem' && o.clipped)) {
    for (i=0; i<pathCount; i++) {
      item = o.pathItems[i];
      if (item.clipping && item.locked && !item.hidden) {
        unlockObject(item);
        break;
      }
    }
  }

  // recursively unlock sub-layers and groups
  forEach(o.groupItems, unlockContainer);
  if (o.typename == 'Layer') {
    forEach(o.layers, unlockContainer);
  }
}


function forEachLayer(cb, parent) {
  var layers = parent ? parent.layers : doc.layers;
  for (var i=0, n=layers.length; i<n; i++) {
    cb(layers[i]);
    forEachLayer(cb, layers[i]);
  }
}

// ===========================
// ai2html program state and settings
// ===========================

function createSettingsBlock() {
  var bounds      = getArtboardBounds();
  var fontSize    = 15;
  var leading     = 22;
  var extraLines  = 6;
  var width       = 400;
  var left        = bounds[0] - width - 50;
  var top         = bounds[1];
  var settingsLines = ["ai2html-settings"];
  var layer, rect, textArea, height;

  for (var name in ai2htmlBaseSettings) {
    if (ai2htmlBaseSettings[name].includeInSettingsBlock) {
      settingsLines.push(name + ": " + ai2htmlBaseSettings[name].defaultValue);
    }
  }

  try {
    layer = doc.layers.getByName("ai2html-settings");
  } catch(e) {
    layer = doc.layers.add();
    layer.zOrder(ZOrderMethod.BRINGTOFRONT);
    layer.name  = "ai2html-settings";
  }

  height = leading * (settingsLines.length + extraLines);
  rect = layer.pathItems.rectangle(top, left, width, height);
  textArea = layer.textFrames.areaText(rect);
  textArea.textRange.autoLeading = false;
  textArea.textRange.characterAttributes.leading = leading;
  textArea.textRange.characterAttributes.size = fontSize;
  textArea.contents = settingsLines.join('\n');
}


// Add ai2html settings contained in a text frame to the document settings object
function parseSettingsTextBlock(frame, docSettings) {
  try {
    for (var p=1; p<frame.paragraphs.length; p++) {
      var thisParagraph    = frame.paragraphs[p].contents;
      var hashKey          = thisParagraph.replace( /^[ \t]*([^ \t:]*)[ \t]*:(.*)$/ , "$1" );
      var hashValue        = thisParagraph.replace( /^[ \t]*([^ \t:]*)[ \t]*:(.*)$/ , "$2" );
      hashKey              = trim(hashKey);
      hashValue            = trim(hashValue);
      hashValue            = straightenCurlyQuotesInsideAngleBrackets(hashValue);

      // replace values from old versions of script with current values
      if (hashKey=="output" && hashValue=="one-file-for-all-artboards") { hashValue="one-file"; }
      if (hashKey=="output" && hashValue=="one-file-per-artboard")      { hashValue="multiple-files"; }
      if (hashKey=="output" && hashValue=="preview-one-file")           { hashValue="one-file"; }
      if (hashKey=="output" && hashValue=="preview-multiple-files")     { hashValue="multiple-files"; }
      // handle stuff that goes in config file and other exceptions, like array values
      if ((hashKey in ai2htmlBaseSettings) && ai2htmlBaseSettings[hashKey].includeInConfigFile) {
        hashValue = (hashValue.replace( /(["])/g , '\\$1' )); // add stuff to ["] for chars that need to be esc in yml file
      } else {
        if ((hashKey in ai2htmlBaseSettings) && ai2htmlBaseSettings[hashKey].inputType=="array") {
          hashValue = hashValue.replace( /[\s,]+/g , ',' );
          if (hashValue.length === 0) {
            hashValue = []; // have to do this because .split always returns an array of length at least 1 even if it's splitting an empty string
          } else {
            hashValue = hashValue.split(",");
          }
        }
      }
      docSettings[hashKey] = hashValue;
    }
  } catch(e) {
    warnings.push("Error parsing settings block: " + e.message);
  }
}

// Show alert or prompt; return true if promo image should be generated
function showCompletionAlert(showPrompt) {
  var rule = "\n================\n";
  var alertText, alertHed, makePromo;

  if (errors.length > 0) {
    alertHed = "The Script Was Unable to Finish";
  } else if (scriptEnvironment == "nyt") {
    alertHed = "Actually, that\u2019s not half bad :)"; // &rsquo;
  } else {
    alertHed = "Nice work!";
  }
  alertText  = makeList(errors, "Error", "Errors");
  alertText += makeList(warnings, "Warning", "Warnings");
  alertText += makeList(feedback, "Information", "Information");
  alertText += "\n";
  if (showPrompt) {
    alertText += rule + "Generate promo image?";
    makePromo = confirm(alertHed  + alertText, true); // true: "No" is default
  } else {
    alertText += rule + "ai2html-nyt5 v" + scriptVersion;
    alert(alertHed + alertText);
    makePromo = false;
  }

  function makeList(items, singular, plural) {
    var list = "";
    if (items.length > 0) {
      list += "\r" + (items.length == 1 ? singular : plural) + rule;
      for (var i = 0; i < items.length; i++) {
        list += "\u2022 " + items[i] + "\r";
      }
    }
    return list;
  }
  return makePromo;
}

function restoreDocumentState() {
  var i;
  for (i = 0; i<textFramesToUnhide.length; i++) {
    textFramesToUnhide[i].hidden = false;
  }
  for (i = objectsToRelock.length-1; i>=0; i--) {
    objectsToRelock[i].locked = true;
  }
}


// ==============================
// ai2html text functions
// ==============================

function textIsTransformed(textFrame) {
  return !(textFrame.matrix.mValueA == 1 &&
    textFrame.matrix.mValueB === 0 &&
    textFrame.matrix.mValueC === 0 &&
    textFrame.matrix.mValueD === 1);
    // || textFrame.textRange.characterAttributes.horizontalScale != 100
    // || textFrame.textRange.characterAttributes.verticalScale != 100;
}

function hideTextFrame(textFrame) {
  textFramesToUnhide.push(textFrame);
  textFrame.hidden = true;
}

// Parse an AI CharacterAttributes object
function getCharStyle(c) {
  var fill = c.fillColor;
  var filltype = fill.typename;
  var caps = String(c.capitalization);
  var o = {
    aifont: c.textFont.name,
    size: Math.round(c.size),
    capitalization: caps == 'FontCapsOption.NORMALCAPS' ? '' : caps,
    tracking: c.tracking
  };
  var r, g, b;

  if (filltype == 'RGBColor') {
    r = fill.red;
    g = fill.green;
    b = fill.blue;
    if (r < rgbBlackThreshold && g < rgbBlackThreshold && b < rgbBlackThreshold) {
      r = g = b = 0;
    }
  } else if (filltype == 'GrayColor') {
    r = g = b = Math.round((100 - fill.gray) / 100 * 255);
  } else if (filltype == 'NoColor') {
    g = 255;
    r = b = 0;
    // warnings are processed later, after ranges of same-style chars are identified
    o.warning = "Some text has no fill. Please fill it with an RGB color. It has been filled with green.";
  } else {
    r = g = b = 0;
    o.warning = "Some text has " + filltype + " fill. Please fill it with an RGB color.";
  }
  o.color = getCssColor(r, g, b);
  return o;
}

function getParagraphStyle(p) {
  var s = {};
  s.leading = Math.round(p.leading);
  s.spaceBefore = Math.round(p.spaceBefore);
  s.spaceAfter = Math.round(p.spaceAfter);
  s.justification = String(p.justification);
  return s;
}

// s: style object
function getStyleKey(s) {
  // TODO: improve
  var key = '';
  for (var i=0, n=textStyleKeys.length; i<n; i++) {
    key += '~' + (s[textStyleKeys[i]] || '');
  }
  return key;
}

function getTextStyleClass(style, classes, name) {
  var key = getStyleKey(style);
  var cname = nameSpace + (name || 'style');
  var o, i, classname;
  for (i=0; i<classes.length; i++) {
    o = classes[i];
    if (o.key == key) {
      return o.classname;
    }
  }
  classname = cname + i;
  o = {
    key: key,
    style: style,
    classname: classname
  };
  classes.push(o);
  return o.classname;
}

// Divide a paragraph (TextRange object) into an array of
// JS objects describing text strings having the same style.
function getParagraphRanges(p) {
  var segments = [];
  var currRange;
  var prev, curr, c;
  for (var i=0, n=p.characters.length; i<n; i++) {
    c = p.characters[i];
    curr = getCharStyle(c);
    if (!prev || objectSubtract(curr, prev)) {
      currRange = {
        text: "",
        style: curr
      };
      segments.push(currRange);
    }
    if (curr.warning) {
      currRange.warning = curr.warning;
    }
    currRange.text += c.contents;
    prev = curr;
  }
  return segments;
}

// Convert a TextFrame to an array of data records for each of the paragraphs
//   contained in the TextFrame.
function convertTextFrame(textFrame) {
  // The scripting API doesn't give us access to opacity of TextRange objects
  //   (including individual characters). The best we can do is get the
  //   computed opacity of the current TextFrame
  var opacity = getComputedOpacity(textFrame);
  var data = [];
  var p, d, style;
  for (var k=0, n=textFrame.paragraphs.length; k<n; k++) {
    p = textFrame.paragraphs[k];
    if (p.characters.length === 0) {
      d = {
        text: "",
        style: {},
        ranges: []
      };
    } else {
      style = getParagraphStyle(p);
      style.opacity = opacity;
      d = {
        text: p.contents,
        style: style,
        ranges: getParagraphRanges(p)
      };
    }
    data.push(d);
  }
  return data;
}

function handleHtmlTags(str) {
  var tagName = findHtmlTag(str);
  if (tagName && !contains(htmlTags, tagName)) {
    warnings.push("Found a <" + tagName + "> tag. Try using Illustrator formatting instead.");
    htmlTags.push(tagName);
  }
}

function generateParagraphHtml(pData, baseStyle, styles) {
  var html, diff, classname, range, text;
  if (pData.text.length === 0) { // empty pg
    // TODO: Calculate the height of empty paragraphs and generate
    // CSS to preserve this height (not supported by Illustrator API)
    return '<p>&nbsp;</p>';
  }
  diff = objectSubtract(pData.style, baseStyle);
  if (diff) {
    classname = getTextStyleClass(pData.style, styles, 'aiPstyle');
    html = '<p class="' + classname + '">';
  } else {
    html = '<p>';
  }
  for (var j=0; j<pData.ranges.length; j++) {
    range = pData.ranges[j];
    if (range.warning) {
      warnings.push(range.warning + " Text: \u201C" + range.text + "\u201D");
    }
    handleHtmlTags(range.text);
    diff = objectSubtract(range.style, baseStyle);
    if (diff) {
      classname = getTextStyleClass(range.style, styles, 'aiCstyle');
      html += '<span class="' + classname + '">';
    }
    html += cleanText(range.text);
    if (diff) {
      html += '</span>';
    }
  }
  html += '</p>';
  return html;
}

function generateTextFrameHtml(paragraphs, baseStyle, styles) {
  var html = "";
  for (var i=0; i<paragraphs.length; i++) {
    html += '\r\t\t\t' + generateParagraphHtml(paragraphs[i], baseStyle, styles);
  }
  return html;
}

// Convert a collection of TextFrames to HTML and CSS
function convertTextFrames(textFrames, ab) {
  var idPrefix = nameSpace + "ai" + getArtboardId(ab) + "-";
  var frameData = map(textFrames, function(frame, i) {
    return {
      id: frame.name ? makeKeyword(frame.name) : idPrefix  + (i + 1),
      css: getTextPositionCss(frame, ab),
      paragraphs: convertTextFrame(frame)
    };
  });
  var baseAiStyle = analyzeTextStyles(frameData);
  var classes = [];
  var divs = map(frameData, function(obj, i) {
    return '\t\t<div id="' + obj.id + '" ' + obj.css + '>' +
        generateTextFrameHtml(obj.paragraphs, baseAiStyle, classes) + '\r\t\t</div>\r';
  });
  var baseCssStyle = convertTextStyle(baseAiStyle);
  var cssBlocks = map(classes, function(obj) {
    var cssStyle = convertTextStyle(obj.style);
    var styleDiff = objectSubtract(cssStyle, baseCssStyle);
    var cssBlock = styleDiff ? formatCss(styleDiff, '\t\t\t\t') : '\r';
    if (!styleDiff) {
      // A class was created for a paragraph or text range with
      // the same CSS properties as the base style. This should not occur
      // and should be investigated.
      warnings.push('CSS class ' + obj.classname + ' is empty');
    }
    return '.' + obj.classname + ' {' + cssBlock + '\t\t\t}\r';
  });
  if (divs.length > 0) {
    cssBlocks.unshift('p {' + formatCss(baseCssStyle, '\t\t\t\t') + '\t\t\t}\r');
  }

  return {
    styles: cssBlocks,
    html: divs.join('')
  };
}

// Find the most common paragraph and character styles in a collection of parsed TextFrames
// frameData: Array of data objects parsed from a collection of TextFrames
// Returns object containing text style properties
function analyzeTextStyles(frameData) {
  var pStyles = [];
  var cStyles = [];
  var baseStyle = {
    aifont: 'NYTFranklin-Medium',
    size: 13,
    weight: 500,
    color: getCssColor(0, 0, 0),
    leading: 18
  };
  // override detected settings with these style properties
  // (to prevent errors when diffing css styles)
  var constantStyle = {
    capitalization: '',
    spaceBefore: 0,
    spaceAfter: 0,
    opacity: 100
  };

  forEach(frameData, function(frame) {
    forEach(frame.paragraphs, analyzeParagraphStyle);
  });

  // find most commn style
  cStyles.sort(compare);
  if (pStyles.length > 0) {
    pStyles.sort(compare);
    extend(baseStyle, pStyles[0].style);
  }
  if (cStyles.length > 0) {
    cStyles.sort(compare);
    extend(baseStyle, cStyles[0].style);
  }
  // override detected styles with constant styles
  extend(baseStyle, constantStyle);

  return baseStyle;

  function compare(a, b) {
    return b.length - a.length;
  }

  function analyzeParagraphStyle(pdata) {
    analyzeTextStyle(pdata.style, pdata.text.length, pStyles);
    forEach(pdata.ranges, analyzeRangeStyle);
  }

  function analyzeRangeStyle(range) {
    analyzeTextStyle(range.style, range.text.length, cStyles);
  }

  function analyzeTextStyle(style, len, stylesArr) {
    var key = getStyleKey(style);
    var o;
    if (len > 0 === false) {
      return;
    }
    for (var i=0; i<stylesArr.length; i++) {
      o = stylesArr[i];
      if (o.key == key) {
        o.length += len;
        return;
      }
    }
    stylesArr.push({
      key: key,
      style: style,
      length: len
    });
  }
}

// Lookup an AI font name in the font table
function findFontInfo(aifont) {
  var info = null;
  for (var k=0; k<fonts.length; k++) {
    if (aifont == fonts[k].aifont) {
      info = fonts[k];
      break;
    }
  }
  if (!info && !contains(unknownFonts, aifont)) {
    // TODO: add affected text to this warning
    unknownFonts.push(aifont);
    warnings.push("Missing a rule for converting font: " + aifont);
  }
  if (!info) {
    // font not found... parse the AI font name to give it a weight and style
    info = {};
    if (aifont.indexOf('Italic') > -1) {
      info.style = 'italic';
    }
    if (aifont.indexOf('Bold') > -1) {
      info.weight = 700;
    } else {
      info.weight = 500;
    }
  }
  return info;
}

// ai: AI justification value
function getJustificationCss(ai) {
  for (var k=0; k<align.length; k++) {
    if (ai == align[k].ai) {
      return align[k].html;
    }
  }
  return "initial"; // CSS default
}

// ai: AI capitalization value
function getCapitalizationCss(ai) {
  for (k=0; k<caps.length; k++) {
    if (ai == caps[k].ai) {
      return caps[k].html;
    }
  }
  return "";
}

// convert an object containing parsed AI text styles to an object containing CSS style properties
function convertTextStyle(aiStyle) {
  var cssStyle = {};
  var fontInfo, tmp;
  if (aiStyle.aifont) {
    fontInfo = findFontInfo(aiStyle.aifont);
    if (fontInfo.family) {
      cssStyle["font-family"] = fontInfo.family;
    }
    if (fontInfo.weight) {
      cssStyle["font-weight"] = fontInfo.weight;
    }
    if (fontInfo.style) {
      cssStyle["font-style"] = fontInfo.style;
    }
  }
  if (aiStyle.size > 0) {
    cssStyle["font-size"] = aiStyle.size + "px";
  }
  if ('leading' in aiStyle) {
    cssStyle["line-height"] = aiStyle.leading + "px";
  }
  if (('opacity' in aiStyle) && aiStyle.opacity < 100) {
    cssStyle.filter = "alpha(opacity=" + Math.round(aiStyle.opacity) + ")";
    cssStyle["-ms-filter"] = "progid:DXImageTransform.Microsoft.Alpha(Opacity=" +
        Math.round(aiStyle.opacity) + ")";
    cssStyle.opacity = roundTo(aiStyle.opacity / 100, cssPrecision);
  }
  if (aiStyle.spaceBefore > 0) {
    cssStyle["padding-top"] = aiStyle.spaceBefore + "px";
  }
  if (aiStyle.spaceAfter > 0) {
    cssStyle["padding-bottom"] = aiStyle.spaceAfter + "px";
  }
  if ('tracking' in aiStyle) {
    cssStyle["letter-spacing"] = roundTo(aiStyle.tracking / 1200, cssPrecision) + "em";
  }
  if (aiStyle.justification && (tmp = getJustificationCss(aiStyle.justification))) {
    cssStyle["text-align"] = tmp;
  }
  if (aiStyle.capitalization && (tmp = getCapitalizationCss(aiStyle.capitalization))) {
    cssStyle["text-transform"] = tmp;
  }
  if (aiStyle.color) {
    cssStyle.color = aiStyle.color;
  }
  return cssStyle;
}

function textFrameIsRenderable(frame, artboardRect) {
  var good = true;
  if (!testBoundsIntersection(frame.visibleBounds, artboardRect)) {
    good = false;
  } else if (frame.kind != "TextType.AREATEXT" && frame.kind != "TextType.POINTTEXT") {
    good = false;
  } else if (objectIsHidden(frame)) {
    good = false;
  } else if (frame.contents === "") {
    good = false;
  } else if (docSettings.render_rotated_skewed_text_as == "image" && textIsTransformed(frame)) {
    good = false;
  }
  return good;
}

// Find clipped art objects that are inside an artboard but outside the bounding box
// box of their clipping path
// items: array of PageItems assocated with a clipping path
// clipRect: bounding box of clipping path
// abRect: bounds of artboard to test
//
function selectMaskedItems(items, clipRect, abRect) {
  var found = [];
  var itemRect, itemInArtboard, itemInMask, maskInArtboard;
  for (var i=0; i<items.length; i++) {
    itemRect = items[i].geometricBounds;
    // capture items that intersect the artboard but are masked...
    itemInArtboard = testBoundsIntersection(abRect, itemRect);
    maskInArtboard = testBoundsIntersection(abRect, clipRect);
    itemInMask = testBoundsIntersection(itemRect, clipRect);
    if (itemInArtboard && (!maskInArtboard || !itemInMask)) {
      found.push(items[i]);
    }
  }
  return found;
}


// Find clipped TextFrames that are inside an artboard but outside their
// clipping path (using bounding box of clipping path to approximate clip area)
function getClippedTextFramesByArtboard(ab, masks) {
  var abRect = ab.artboardRect;
  var frames = [];
  forEach(masks, function(o) {
    var clipRect = o.mask.geometricBounds;
    if (testSimilarBounds(abRect, clipRect, 5)) {
      // if clip path is masking the current artboard, skip the test
      // (optimization)
      return;
    }
    var texts = filter(o.items, function(item) {return item.typename == 'TextFrame';});
    texts = selectMaskedItems(texts, clipRect, abRect);
    if (texts.length > 0) {
      frames = frames.concat(texts);
    }
  });
  return frames;
}


// Get array of TextFrames belonging to an artboard, excluding text that
// overlaps the artboard but is hidden by a clipping mask
function getTextFramesByArtboard(ab, masks) {
  var candidateFrames = findTextFramesToRender(doc.textFrames, ab.artboardRect);
  var excludedFrames = getClippedTextFramesByArtboard(ab, masks);
  var goodFrames = arraySubtract(candidateFrames, excludedFrames);
  return goodFrames;
}

function findTextFramesToRender(frames, artboardRect) {
  var selected = [];
  for (var i=0; i<frames.length; i++) {
    if (textFrameIsRenderable(frames[i], artboardRect)) {
      selected.push(frames[i]);
    }
  }
  // Sort frames top to bottom, left to right.
  selected.sort(
      firstBy(function (v1, v2) { return v2.top  - v1.top; })
      .thenBy(function (v1, v2) { return v1.left - v2.left; })
  );
  return selected;
}

function parseTextFrameNote(note) {
  // Read in attribute variables from notes field of a text frame
  var thisFrameAttributes = {};
  var rawNotes = note.split("\r");
  for (var rNo = 0; rNo < rawNotes.length; rNo++) {
    var rn = rawNotes[rNo];
    var rnKey   = rn.replace( /^[ \t]*([^ \t:]*)[ \t]*:(.*)$/ , "$1" );
    var rnValue = rn.replace( /^[ \t]*([^ \t:]*)[ \t]*:(.*)$/ , "$2" );
    rnKey       = rnKey.replace( /^\s+/ , "" ).replace( /\s+$/ , "" );
    rnValue     = rnValue.replace( /^\s+/ , "" ).replace( /\s+$/ , "" );
    thisFrameAttributes[rnKey] = rnValue;
  }
  return thisFrameAttributes;
}

// Create class="" and style="" CSS for positioning a text div
function getTextPositionCss(thisFrame, ab) {
  var style = "";
  var vFactor = 0.5; // This is an adjustment to correct for vertical placement.
  var kind, htmlY, htmlT, htmlB, htmlTM, htmlH, htmlL, htmlR, htmlW, htmlLM, alignment, extraWidthPct;
  var thisFrameAttributes = parseTextFrameNote(thisFrame.note);
  var abPos = getArtboardPos(ab);

  if (thisFrame.kind=="TextType.POINTTEXT") {
    kind = "point";
    // /this line throws an error if the first paragraph of the frame is empty.
    // var htmlY = Math.round(-thisFrame.position[1] - (((thisFrame.paragraphs[0].characters[0].leading - thisFrame.paragraphs[0].characters[0].size)*vFactor) + thisFrame.paragraphs[0].spaceBefore)-abY);
    htmlY = Math.round(-thisFrame.position[1] - (((thisFrame.characters[0].leading - thisFrame.characters[0].size)*vFactor) + thisFrame.characters[0].spaceBefore) - abPos.y);
  } else if (thisFrame.kind=="TextType.AREATEXT") {
    kind = "area";
    // var htmlY = Math.round(-thisFrame.position[1] - (((thisFrame.paragraphs[0].characters[0].leading - thisFrame.paragraphs[0].characters[0].size)*vFactor) + thisFrame.paragraphs[0].spaceBefore)-abY);
    htmlY = Math.round(-thisFrame.position[1] - (((thisFrame.characters[0].leading - thisFrame.characters[0].size)*vFactor) + thisFrame.characters[0].spaceBefore) - abPos.y);
  } else {
    kind = "other";
  }
  htmlH = Math.round(thisFrame.height);
  if (thisFrameAttributes.valign === "bottom") {
    htmlB = htmlY + thisFrame.height;
  // } else if (thisFrameAttributes.valign==="center") {
  //  htmlT  = htmlY+(thisFrame.height/2);
  //  htmlTM = thisFrame.height*(1/2*-1);
  } else {
    htmlT = htmlY;
  }

  // additional width for box to allow for slight variations in font widths
  if (kind=="area") {
    extraWidthPct = 0; // was 3 percent -- but need to account for when it hits the edge of the box since we are now overflow hidden
  } else {
    extraWidthPct = 100;
  }
  htmlW = thisFrame.width*(1+(extraWidthPct/100));
  if (thisFrame.characters[0].justification=="Justification.LEFT") {
    alignment = "left";
    htmlL = thisFrame.left - abPos.x;
    htmlR = abPos.width - (thisFrame.left + htmlW - abPos.x);
  } else if (thisFrame.characters[0].justification=="Justification.RIGHT") {
    alignment = "right";
    htmlL = thisFrame.left - (thisFrame.width * (1 + (extraWidthPct / 100))) - abPos.x;
    htmlR = abPos.width - (thisFrame.left + thisFrame.width - abPos.x);
  } else if (thisFrame.characters[0].justification=="Justification.CENTER") {
    alignment = "center";
    htmlL  = thisFrame.left - abPos.x +  (thisFrame.width / 2); // thanks jeremy!
    htmlLM = thisFrame.width * (1 + (extraWidthPct/100)) / 2 * -1;
  } else {
    alignment = "other";
    // htmlX = Math.round(thisFrame.left-abX);
  }

  // check if text is transformed
  if (textIsTransformed(thisFrame)) {
    // find transformed anchor point pre-transformation
    var t_bounds = thisFrame.geometricBounds,
      u_bounds = getUntransformedTextBounds(thisFrame),
      u_width = u_bounds[2] - u_bounds[0],
      t_width = t_bounds[2] - t_bounds[0],
      u_height = u_bounds[3] - u_bounds[1],
      t_height = t_bounds[3] - t_bounds[1],
      v_align = thisFrameAttributes.valign || 'top',
      t_scale_x = thisFrame.textRange.characterAttributes.horizontalScale / 100,
      t_scale_y = thisFrame.textRange.characterAttributes.verticalScale / 100,
      t_anchor = getAnchorPoint(u_bounds, thisFrame.matrix, alignment, v_align, t_scale_x, t_scale_y),
      t_trans_x = 0,
      t_trans_y = 0;

    // position div on transformed anchor point
    style += "left:" + roundTo((t_anchor[0] - abPos.x) / abPos.width * 100, cssPrecision) + "%;";
    style += "top:" + roundTo((-t_anchor[1]- abPos.y) / abPos.height * 100, cssPrecision) + "%;";

    // move "back" to left or top to center or right align text
    if (alignment == 'center') t_trans_x -= u_width * 0.5;
    else if (alignment == 'right') t_trans_x -= u_width;
    if (v_align == 'center' || v_align == 'middle') t_trans_y -= u_height * 0.5;
    else if (v_align == 'bottom') t_trans_y -= u_height;

    var mat = thisFrame.matrix;

    mat = app.concatenateMatrix(app.getTranslationMatrix(t_trans_x, t_trans_y),
        app.concatenateTranslationMatrix(mat, -mat.mValueTX, -mat.mValueTY));

    // var mat, mat0 = thisFrame.matrix;
    // mat0 = app.concatenateTranslationMatrix(mat0, -mat0.mValueTX, -mat0.mValueTY);
    // mat = app.concatenateMatrix(app.getTranslationMatrix(t_trans_x, t_trans_y), mat0);

    var transform = "matrix(" +
        roundTo(mat.mValueA, cssPrecision) + ',' +
        roundTo(-1*mat.mValueB, cssPrecision) + ',' +
        roundTo(-1*mat.mValueC, cssPrecision) + ',' +
        roundTo(mat.mValueD, cssPrecision) + ',' +
        roundTo(t_trans_x, cssPrecision) + ',' +
        roundTo(-t_trans_y, cssPrecision) + ') ' +
        "scaleX("+roundTo(t_scale_x, cssPrecision) + ") " +
        "scaleY("+roundTo(t_scale_y, cssPrecision) + ")";

    var transformOrigin = alignment + ' '+(v_align == 'middle' ? 'center' : v_align);

    style += "transform: " + transform + ";";
    style += "transform-origin: " + transformOrigin + ";";
    style += "-webkit-transform: " + transform + ";";
    style += "-webkit-transform-origin: " + transformOrigin + ";";
    style += "-ms-transform: " + transform + ";";
    style += "-ms-transform-origin: " + transformOrigin + ";";

    if (kind == 'area') style += "width: " + (u_width * (1 + (extraWidthPct/100))) + "px;";

  } else {
    if (thisFrameAttributes.valign==="bottom") {
      style += "bottom:" + roundTo(100 - (htmlB / abPos.height * 100), cssPrecision) + "%;";
    } else {
      style += "top:" + roundTo(htmlT / abPos.height * 100, cssPrecision) + "%;";
    }
    if (alignment=="right") {
      style += "right:" + roundTo(htmlR / abPos.width * 100, cssPrecision) + "%;";
      if (kind=="area") {
        style += "width:" + roundTo(htmlW / abPos.width * 100, cssPrecision) + "%;";
      }
    } else if (alignment=="center") {
      style += "left:" + roundTo(htmlL / abPos.width * 100, cssPrecision) + "%;";
      style += "width:" + roundTo(htmlW / abPos.width * 100, cssPrecision) + "%;";
      style += "margin-left:" + roundTo(htmlLM / abPos.width * 100, cssPrecision) + "%;";
    } else {
      style += "left:" + roundTo(htmlL / abPos.width * 100, cssPrecision) + "%;";
      if (kind=="area") {
        style += "width:" + roundTo(htmlW / abPos.width * 100, cssPrecision) + "%;";
      }
    }
  }
  var frameLayer = makeKeyword(thisFrame.layer.name);
  return 'class="' + nameSpace + frameLayer + " " + nameSpace + "aiAbs" +
    (textIsTransformed(thisFrame) && kind == "point" ? ' g-aiPtransformed' : '') +
    '" style="' + style + '"';
}

function getAnchorPoint(untransformedBounds, matrix, hAlign, vAlign, sx, sy) {
  var center_x = (untransformedBounds[0] + untransformedBounds[2]) * 0.5,
    center_y = (untransformedBounds[1] + untransformedBounds[3]) * 0.5,
    anchor_x = (hAlign == 'left' ? untransformedBounds[0] :
      (hAlign == 'center' ? center_x : untransformedBounds[2])),
    anchor_y = (vAlign == 'top' ? untransformedBounds[1] :
      (vAlign == 'bottom' ? untransformedBounds[3] : center_y)),
    anchor_dx = (anchor_x - center_x),
    anchor_dy = (anchor_y - center_y);

  var mat = app.concatenateMatrix(app.getScaleMatrix(sx*100, sy*100), matrix);

  var t_anchor_x = center_x + mat.mValueA * anchor_dx + mat.mValueC * anchor_dy,
    t_anchor_y = center_y + mat.mValueB * anchor_dx + mat.mValueD * anchor_dy;

  return [t_anchor_x, t_anchor_y];
}

function getUntransformedTextBounds(textFrame) {
  var textFrameCopy = textFrame.duplicate(textFrame.parent, ElementPlacement.PLACEATEND);
  var bnds = textFrameCopy.geometricBounds;
  var old_center_x = (bnds[0] + bnds[2]) * 0.5,
    old_center_y = (bnds[1] + bnds[3]) * 0.5;
  var new_center_x, new_center_y;
  var max_iter = 5;

  // inverse transformation of copied text frame
  textFrameCopy.transform(app.invertMatrix(textFrame.matrix));
  // remove scale
  textFrameCopy.textRange.characterAttributes.horizontalScale = 100;
  textFrameCopy.textRange.characterAttributes.verticalScale = 100;
  // move transformed text frame back to old center point
  while (--max_iter > 0) {
    bnds = textFrameCopy.geometricBounds;
    new_center_x = (bnds[0] + bnds[2]) * 0.5;
    new_center_y = (bnds[1] + bnds[3]) * 0.5;
    textFrameCopy.translate(old_center_x - new_center_x, old_center_y - new_center_y);
  }
  bnds = textFrameCopy.geometricBounds;
  textFrameCopy.remove();
  return bnds;
}

// ==============================
// ai2html artboard functions
// ==============================

function getArtboardPos(ab) {
  var rect = ab.artboardRect,
      x = rect[0],
      y = -rect[1],
      w = Math.round(rect[2] - x),
      h = -rect[3] - y;
  return {
    x: x,
    y: y,
    width: w,
    height: h
  };
}

// Get numerical index of an artboard in the doc.artboards array
function getArtboardId(ab) {
  var id = 0;
  forEachUsableArtboard(function(ab2, i) {
    if (ab === ab2) id = i;
  });
  return id;
}

// TODO: prevent duplicate names? or treat duplicate names an an error condition?
// (artboard name is assumed to be unique in several places)
function getArtboardName(ab) {
  return makeKeyword(ab.name.replace( /^(.+):\d+$/, "$1"));
}

function getArtboardFullName(ab) {
  return docName + "-" + getArtboardName(ab);
}

// return rect of bounding box of all artboards
function getArtboardBounds() {
  var rect, bounds;
  for (var i=0, n=doc.artboards.length; i<n; i++) {
    rect = doc.artboards[i].artboardRect;
    if (i === 0) {
      bounds = rect;
    } else {
      bounds = [
        Math.min(rect[0], bounds[0]), Math.max(rect[1], bounds[1]),
        Math.max(rect[2], bounds[2]), Math.min(rect[3], bounds[3])];
    }
  }
  return bounds;
}

// return responsive artboard widths as an array [minw, maxw]
function getArtboardWidthRange(ab) {
  var id = getArtboardId(ab);
  var infoArr = getArtboardInfo();
  var minw, maxw;
  // find min width, which is the artboard's own effective width
  forEach(infoArr, function(info) {
    if (info.id == id) {
      minw = info.effectiveWidth;
    }
  });
  // find max width, which is the effective width of the next widest
  // artboard (if any), minus one pixel
  forEach(infoArr, function(info) {
    var w = info.effectiveWidth;
    if (w > minw && (!maxw || w < maxw)) {
      maxw = w;
    }
  });
  return [minw, maxw ? maxw - 1 : Infinity];
}

// return array of data records about each usable artboard, sorted from narrow to wide
function getArtboardInfo() {
  var artboards = [];
  forEachUsableArtboard(function(ab, i) {
    var pos = getArtboardPos(ab);
    var name = ab.name || "";
    // parse width from artboard name in two formats: <name>:<width> and ai2html-<width>
    var widthFromName = (/^(?:.*:|ai2html-)(\d+)$/.exec(name) || [])[1];
    artboards.push({
      name: ab.name || "",
      width: pos.width,
      effectiveWidth: widthFromName ? +widthFromName : pos.width,
      id: i
    });
  });
  artboards.sort(function(a, b) {return a.effectiveWidth - b.effectiveWidth;});
  return artboards;
}

function findShowClassesForArtboard(ab, breakpoints) {
  var classes = [];
  var id = getArtboardId(ab);
  forEach(breakpoints, function(bp) {
    if (contains(bp.artboards, id)) {
      classes.push('g-show-' + bp.name);
    }
  });
  return classes.join(' ');
}

// Get array of data records for breakpoints that have artboards assigned to them
// (sorted from narrow to wide)
// breakpoints: Array of data about all possible breakpoints
function assignBreakpointsToArtboards(breakpoints) {
  var abArr = getArtboardInfo(); // get data records for each artboard
  var bpArr = [];
  forEach(breakpoints, function(breakpoint) {
    var bpPrev = bpArr[bpArr.length - 1],
        bpInfo = {
          name: breakpoint.name,
          lowerLimit: breakpoint.lowerLimit,
          upperLimit: breakpoint.upperLimit,
          artboards: []
        },
        abInfo;
    for (var i=0; i<abArr.length; i++) {
      abInfo = abArr[i];
      if (abInfo.effectiveWidth <= breakpoint.upperLimit &&
          abInfo.effectiveWidth > breakpoint.lowerLimit) {
        bpInfo.artboards.push(abInfo.id);
      }
    }
    if (bpInfo.artboards.length > 1 && scriptEnvironment=="nyt") {
      warnings.push('The ' + breakpoint.upperLimit + "px breakpoint has " + bpInfo.artboards.length +
          " artboards. You probably want only one artboard per breakpoint.");
    }
    if (bpInfo.artboards.length === 0 && bpPrev) {
      bpInfo.artboards = bpPrev.artboards.concat();
    }
    if (bpInfo.artboards.length > 0) {
      bpArr.push(bpInfo);
    }
  });
  return bpArr;
}

function forEachUsableArtboard(cb) {
  var ab;
  for (var i=0; i<doc.artboards.length; i++) {
    ab = doc.artboards[i];
    if (!/^-/.test(ab.name)) { // exclude artboards with names starting w/ "-"
      cb(ab, i);
    }
  }
}

// Returns id of artboard with largest area
function findLargestArtboard() {
  var largestId = -1;
  var largestArea = 0;
  forEachUsableArtboard(function(ab, i) {
    var info = getArtboardPos(ab);
    var area = info.width * info.height;
    if (area > largestArea) {
      largestId = i;
      largestArea = area;
    }
  });
  return largestId;
}

function hideElementsOutsideArtboard(ab) {
  var artboardRect = ab.artboardRect;
  var hidden = [];
  forEachLayer(function(layer) {
    if (layer.visible) { // only deal with visible layers
      forEach(layer.pathItems, hideIfOutside);
      forEach(layer.symbolItems, hideIfOutside);
      forEach(layer.compoundPathItems, hideIfOutside);
      forEach(layer.groupItems, hideOutsideGroup);
    }
  });
  function hideIfOutside(item) {
    if (!testBoundsIntersection(item.visibleBounds, artboardRect)) {
      item.hidden = true;
      hidden.push(item);
    }
  }
  function hideOutsideGroup(group) {
    hideIfOutside(group);
    forEach(group.groupItems, hideOutsideGroup);
  }
  return hidden;
}


function clearSelection() {
  // setting selection to null doesn't always work:
  // it doesn't deselect text range selection and also seems to interfere with
  // subsequent mask operations using executeMenuCommand().
  // doc.selection = null;
  // the following seems to work reliably.
  app.executeMenuCommand('deselectall');
}

// =================================
// ai2html image functions
// =================================

// ab: artboard (assumed to be the active artboard)
// textFrames:  text frames belonging to the active artboard
function captureArtboardImage(ab, textFrames, masks, settings) {
  var docArtboardName = getArtboardFullName(ab);
  var imageDestinationFolder = docPath + settings.html_output_path + settings.image_output_path;
  var imageDestination = imageDestinationFolder + docArtboardName;
  var i;
  checkForOutputFolder(imageDestinationFolder, "image_output_path");

  if (settings.testing_mode != "yes") {
    for (i=0; i<textFrames.length; i++) {
      textFrames[i].hidden = true;
    }
  }

  exportImageFiles(imageDestination, ab, settings.image_format, 1, docSettings.use_2x_images_if_possible);
  if (contains(settings.image_format, 'svg')) {
    exportSVG(imageDestination, ab, masks);
  }

  if (settings.testing_mode != "yes") {
    for (i=0; i<textFrames.length; i++) {
      textFrames[i].hidden = false;
    }
  }
}

// Create an <img> tag for the artboard image
function generateImageHtml(ab, settings) {
  var abName = getArtboardFullName(ab),
      abPos = getArtboardPos(ab),
      imgId = nameSpace + "ai" + getArtboardId(ab) + "-0",
      extension = (settings.image_format[0] || "png").substring(0,3),
      src = settings.image_source_path + abName + "." + extension,
      html;

  html = '\t\t<img id="' + imgId + '" class="' + nameSpace + 'aiImg"';
  if (isTrue(settings.use_lazy_loader)) {
    html += ' data-height-multiplier="' + roundTo(abPos.height / abPos.width, 4) + '"';
    html += ' data-src="' + src + '"';
    // spaceholder while image loads
    src = 'data:image/gif;base64,R0lGODlhCgAKAIAAAB8fHwAAACH5BAEAAAAALAAAAAAKAAoAAAIIhI+py+0PYysAOw==';
  }
  html += ' src="' + src + '"/>\r';
  return html;
}

// Create a promo image from the largest usable artboard
function createPromoImage(settings) {
  var PROMO_WIDTH = 1024;
  var abNumber = findLargestArtboard();
  if (abNumber == -1) return; // TODO: show error

  var artboard         =  doc.artboards[abNumber],
      abPos            =  getArtboardPos(artboard),
      promoScale       =  PROMO_WIDTH / abPos.width,
      promoW           =  abPos.width * promoScale,
      promoH           =  abPos.height * promoScale,
      imageDestination =  docPath + docName + "-promo",
      promoFormat, tmpPngTransparency;

  // Previous file name was more complicated:
  // imageDestination = docPath + docSettings.docName + "-" + makeKeyword(ab.name) + "-" + abNumber + "-promo";

  doc.artboards.setActiveArtboardIndex(abNumber);

  // Using "jpg" if present in image_format setting, else using "png";
  if (contains(settings.image_format, 'jpg')) {
    promoFormat = 'jpg';
  } else {
    promoFormat = 'png';
  }

  tmpPngTransparency = settings.png_transparent;
  settings.png_transparent = "no";
  exportImageFiles(imageDestination, artboard, [promoFormat], promoScale, "no");
  settings.png_transparent = tmpPngTransparency;
  alert("Promo image created\nLocation: " + imageDestination + "." + promoFormat);
}

// Returns 1 or 2 (corresponding to standard pixel scale and "retina" pixel scale)
// format: png, png24 or jpg
// doubleres: yes, always or no (no is default)
function getPixelRatio(width, height, format, doubleres) {
  // Maximum pixel sizes are based on mobile Safari limits
  // TODO: check to see if these numbers are still relevant
  var maxPngSize = 3*1024*1024;
  var maxJpgSize = 32*1024*1024;
  var k = (doubleres == "always" || doubleres == "yes") ? 2 : 1;
  var pixels = width * height * k * k;

  if (doubleres == "yes" && width < 945) { // assume wide images are desktop-only
    // use single res if image might run into mobile browser limits
    if (((format == "png" || format == "png24") && pixels > maxPngSize) ||
        (format == "jpg" && pixels > maxJpgSize)) {
      k = 1;
    }
  }
  return k;
}

// Exports contents of active artboard as an image (without text, unless in test mode)
//
// dest: full path of output file excluding the file extension
// ab: assumed to be active artboard
// formats: array of export format identifiers (png, png24, jpg)
// initialScaling: the proportion to scale the base image before considering whether to double res. Usually just 1.
// doubleres: "yes", "no" or "always" ("yes" may be overridden if the image is very large)
//
function exportImageFiles(dest, ab, formats, initialScaling, doubleres) {

  forEach(formats, function(format) {
    var maxJpgScale  = 776.19; // This is specified in the Illustrator Scripting Reference under ExportOptionsJPEG.
    var abPos = getArtboardPos(ab);
    var width = abPos.width * initialScaling;
    var height = abPos.height * initialScaling;
    var imageScale = 100 * initialScaling * getPixelRatio(width, height, format, doubleres);
    var exportOptions, fileType;

    if (format=="png") {
      fileType = ExportType.PNG8;
      exportOptions = new ExportOptionsPNG8();
      exportOptions.colorCount       = docSettings.png_number_of_colors;
      exportOptions.transparency     = isTrue(docSettings.png_transparent);

    } else if (format=="png24") {
      fileType = ExportType.PNG24;
      exportOptions = new ExportOptionsPNG24();
      exportOptions.transparency     = isTrue(docSettings.png_transparent);

    } else if (format=="jpg") {
      if (imageScale > maxJpgScale) {
        imageScale = maxJpgScale;
        warnings.push(dest.split("/").pop() + ".jpg was output at a smaller size than desired because of a limit on jpg exports in Illustrator." +
          " If the file needs to be larger, change the image format to png which does not appear to have limits.");
      }
      fileType = ExportType.JPEG;
      exportOptions = new ExportOptionsJPEG();
      exportOptions.qualitySetting = docSettings.jpg_quality;

    } else {
      if (format != "svg") { // svg exported separately
        warnings.push("Unsupported image format: " + format);
      }
      return;
    }

    exportOptions.horizontalScale  = imageScale;
    exportOptions.verticalScale    = imageScale;
    exportOptions.artBoardClipping = true;
    exportOptions.antiAliasing     = false;
    app.activeDocument.exportFile(new File(dest), fileType, exportOptions);
  });
}

// Return array of layer objects, include PageItems and sublayers, in z order
function getSortedLayerItems(lyr) {
  var items = toArray(lyr.pageItems).concat(toArray(lyr.layers));
  if (lyr.layers.length > 0 && lyr.pageItems.length > 0) {
    // only need to sort if layer contains both layers and page objects
    items.sort(function(a, b) {
      return b.absoluteZOrderPosition - a.absoluteZOrderPosition;
    });
  }
  return items;
}

function copyArtboardForImageExport(ab, masks) {
  var layerMasks = filter(masks, function(o) {return !!o.layer;}),
      artboardBounds = ab.artboardRect,
      sourceLayers = toArray(doc.layers),
      destLayer = doc.layers.add(),
      destGroup = doc.groupItems.add(),
      doc2;
  destLayer.name = "ArtboardContent";
  destGroup.move(destLayer, ElementPlacement.PLACEATEND);
  forEach(sourceLayers, copyLayer);
  // Creating a document is pretty slow (~1.5s)
  doc2 = app.documents.add(DocumentColorSpace.RGB, doc.width, doc.height, 1);
  doc2.pageOrigin = doc.pageOrigin; // not sure if needed
  doc2.rulerOrigin = doc.rulerOrigin;
  // need to save group position before copying to second document. Oddly,
  // the reported position of the original group changes after duplication
  var posPre = destGroup.position;
  var copy = destGroup.duplicate(doc2.layers[0], ElementPlacement.PLACEATEND);
  copy.position = posPre;
  destGroup.remove();
  destLayer.remove();
  return doc2;

  function copyLayer(lyr) {
    var mask;
    if (lyr.hidden) return; // ignore hidden layers
    mask = findLayerMask(lyr);
    if (mask) {
      copyMaskedLayerAsGroup(lyr, mask);
    } else {
      forEach(getSortedLayerItems(lyr), copyLayerItem);
    }
  }

  // Item: Layer (sublayer) or PageItem
  function copyLayerItem(item) {
    if (item.typename == 'Layer') {
      copyLayer(item);
    } else {
      copyPageItem(item);
    }
  }

  function copyMaskedLayerAsGroup(lyr, mask) {
    var maskBounds = mask.mask.geometricBounds;
    var newMask, newGroup;
    if (!testBoundsIntersection(artboardBounds, maskBounds)) {
      return;
    }
    newGroup = doc.groupItems.add();
    newGroup.move(destGroup, ElementPlacement.PLACEATEND);
    forEach(mask.items, function(item) {
      copyPageItem(item, newGroup);
    });
    if (newGroup.pageItems.length > 0) {
      newMask = duplicateItem(mask.mask);
      newMask.moveToBeginning(newGroup);
      newGroup.clipped = true;
    } else {
      newGroup.remove();
    }
  }

  function findLayerMask(lyr) {
    return find(layerMasks, function(o) {return o.layer == lyr;});
  }

  function copyPageItem(item, dest) {
    var excluded = item.typename == 'TextFrame' ||
        !testBoundsIntersection(item.geometricBounds, artboardBounds) ||
        objectIsHidden(item) || item.clipping;
    return excluded ? null : duplicateItem(item, dest);
  }

  function duplicateItem(item, dest) {
    return item.duplicate(dest || destGroup, ElementPlacement.PLACEATEND);
  }
}

// a, b: Layer objects
function findCommonLayer(a, b) {
  var p = null;
  if (a == b) {
    p = a;
  }
  if (!p && a.parent.typename == 'Layer') {
    p = findCommonLayer(a.parent, b);
  }
  if (!p && b.parent.typename == 'Layer') {
    p = findCommonLayer(a, b.parent);
  }
  return p;
}

function findCommonAncestorLayer(items) {
  var layers = [],
      ancestorLyr = null,
      item;
  for (var i=0, n=items.length; i<n; i++) {
    item = items[i];
    if (item.parent.typename != 'Layer' || contains(layers, item.parent)) {
      continue;
    }
    // remember layer, to avoid redundant searching (is this worthwhile?)
    layers.push(item.parent);
    if (!ancestorLyr) {
      ancestorLyr = item.parent;
    } else {
      ancestorLyr = findCommonLayer(ancestorLyr, item.parent);
      if (!ancestorLyr) {
        // Failed to find a common ancestor
        return null;
      }
    }
  }
  return ancestorLyr;
}

function findMasks() {
  var found = [],
      masks;
  // assumes clipping paths have been unlocked
  app.executeMenuCommand('Clipping Masks menu item');
  masks = toArray(doc.selection);
  clearSelection();
  forEach(masks, function(mask) {mask.locked = true;});
  forEach(masks, function(mask) {
    var items, obj;
    mask.locked = false;
    // select a single mask
    // some time ago, executeMenuCommand() was more reliable than assigning to
    // selection... no longer, apparently
    // app.executeMenuCommand('Clipping Masks menu item');
    doc.selection = [mask];
    // switch selection to all masked items
    app.executeMenuCommand('editMask'); // Object > Clipping Mask > Edit Contents
    items = toArray(doc.selection || []);
    // oddly, 'deselectall' sometimes fails here
    // app.executeMenuCommand('deselectall');
    doc.selection = null;
    mask.locked = true;
    obj = {
      mask: mask,
      items: items
    };
    if (mask.parent.typename == "GroupItem") {
      // Group mask
      obj.group = mask.parent;

    } else if (mask.parent.typename == "Layer") {
      // Layer mask -- common ancestor layer of all masked items is assumed
      // to be the masked layer
      obj.layer = findCommonAncestorLayer(items);

    } else {
      message("Unknown mask type in findMasks()");
    }

    if (items.length > 0 && (obj.group || obj.layer)) {
      found.push(obj);
    }

    if (items.length === 0) {
      // message("Unable to select masked items");
    }
  });
  forEach(masks, function(mask) {mask.locked = false;});
  return found;
}

function exportSVG(dest, ab, masks) {
  var opts = new ExportOptionsSVG();
  opts.embedAllFonts         = false;
  opts.fontSubsetting        = SVGFontSubsetting.None;
  opts.compressed            = false;
  opts.documentEncoding      = SVGDocumentEncoding.UTF8;
  opts.embedRasterImages     = (docSettings.svg_embed_images==="yes") ? true : false;
  opts.saveMultipleArtboards = false;
  opts.DTD                   = SVGDTDVersion.SVG1_1; // SVG1_0 SVGTINY1_1 <=default SVG1_1 SVGTINY1_1PLUS SVGBASIC1_1 SVGTINY1_2
  opts.cssProperties         = SVGCSSPropertyLocation.STYLEATTRIBUTES; // ENTITIES STYLEATTRIBUTES <=default PRESENTATIONATTRIBUTES STYLEELEMENTS

  // Illustrator's SVG output contains all objects in a document (it doesn't
  //   clip to the current artboard), so we copy artboard objects to a temporary
  //   document for export.
  var exportDoc = copyArtboardForImageExport(ab, masks);
  exportDoc.exportFile(new File(dest), ExportType.SVG, opts);
  doc.activate();
  //exportDoc.pageItems.removeAll();
  exportDoc.close(SaveOptions.DONOTSAVECHANGES);
}

// ===================================
// ai2html output generation functions
// ===================================

function generateArtboardDiv(ab, breakpoints, settings) {
  var divId = nameSpace + getArtboardFullName(ab);
  var classnames = nameSpace + "artboard " + nameSpace + "artboard-v3";
  var widthRange = getArtboardWidthRange(ab);
  var html = "";
  if (settings.include_resizer_classes != "no") {
    classnames += " " + findShowClassesForArtboard(ab, breakpoints);
  }
  html += '\t<div id="' + divId + '" class="' + classnames + '"';
  if (settings.include_resizer_widths == "yes") {
    // add data-min/max-width attributes
    // TODO: see if we can use breakpoint data to set min and max widths
    html += " data-min-width='" + widthRange[0] + "'";
    if (widthRange[1] < Infinity) {
      html += " data-max-width='" + widthRange[1] + "'";
    }
  }
  html += ">\r";
  return html;
}

function generateArtboardCss(ab, textClasses, settings) {
  var t3 = '\t\t\t',
      t4 = t3 + '\t',
      abId = "#" + nameSpace + getArtboardFullName(ab),
      css = "";
  css += "\t\t<style type='text/css' media='screen,print'>\r";
  css += t3 + abId + " {\r";
  css += t4 + "position:relative;\r";
  css += t4 + "overflow:hidden;\r";
  if (settings.responsiveness=="fixed") {
    css += t4 + "width:"  + getArtboardPos(ab).width + "px;\r";
  }
  css += t3 + "}\r";

  // classes for paragraph and character styles
  forEach(textClasses, function(cssBlock) {
    css += t3 + abId + " " + cssBlock;
  });

  css += "\t\t</style>\r";
  return css;
}

// Get CSS styles that are common to all generated content
function generatePageCss(pageName, settings) {
  var css = "\r\t<style type='text/css' media='screen,print'>\r";
  var t2 = '\t\t';
  var t3 = '\t\t\t';
  if (settings.max_width !== "") {
    css += t2 + "#" + nameSpace + pageName + "-box {\r";
    css += t3 + "max-width:" + settings.max_width + "px;\r";
    css += t2 + "}\r";
  }
  if (settings.center_html_output) {
    css += t2 + "." + nameSpace + "artboard {\r";
    css += t3 + "margin:0 auto;\r";
    css += t2 + "}\r";
  }
  if (settings.clickable_link !== "") {
    css += t2 + "." + nameSpace + "ai2htmlLink {\r";
    css += t3 + "display: block;\r";
    css += t2 + "}\r";
  }
  // default <p> styles
  css += t2 + "." + nameSpace + "artboard p {\r";
  css += t3 + "margin:0;\r";
  if (settings.testing_mode == "yes") {
    css += t3 + "color: rgba(209, 0, 0, 0.5) !important;\r";
  }
  css += t2 + "}\r";

  css += t2 + "." + nameSpace + "aiAbs {\r";
  css += t3 + "position:absolute;\r";
  css += t2 + "}\r";

  css += t2 + "." + nameSpace + "aiImg {\r";
  css += t3 + "display:block;\r";
  css += t3 + "width:100% !important;\r";
  css += t2 + "}\r";

  css += t2 + '.g-aiPtransformed p { white-space: nowrap; }\r'; // TODO: move to page css block
  css += "\t</style>\r";
  return css;
}

function generateYmlFileContent(breakpoints, settings) {
  var lines = [];
  lines.push("ai2html_version: " + scriptVersion);
  lines.push("project_type: " + previewProjectType);
  lines.push("tags: ai2html");
  lines.push("min_width: " + breakpoints[0].upperLimit); // TODO: ask why upperLimit
  if (settings.max_width !== "") {
    lines.push("max_width: " + settings.max_width);
  } else if (settings.responsiveness != "fixed" && settings.ai2html_environment == "nyt") {
    lines.push("max_width: " + breakpoints[breakpoints.length-1].upperLimit);
  } else if (settings.responsiveness != "fixed" && settings.ai2html_environment != "nyt") {
    // don't write a max_width setting as there should be no max width in this case
  } else {
    // this is the case of fixed responsiveness
    lines.push("max_width: " + getArtboardInfo().pop().effectiveWidth);
  }
  // write out remaining values for config file
  for (var setting in settings) {
    if (setting in ai2htmlBaseSettings && ai2htmlBaseSettings[setting].includeInConfigFile) {
      var quoteMark = ai2htmlBaseSettings[setting].useQuoteMarksInConfigFile ? '"': '';
      lines.push(setting + ': ' + quoteMark + settings[setting] + quoteMark);
    }
  }
  return lines.join('\n') + '\n';
}

function checkForOutputFolder(folderPath, nickname) {
  var outputFolder = new Folder( folderPath );
  if (!outputFolder.exists) {
    var outputFolderCreated = outputFolder.create();
    if (outputFolderCreated) {
      feedback.push("The " + nickname + " folder did not exist, so the folder was created.");
    } else {
      warnings.push("The " + nickname + " folder did not exist and could not be created.");
    }
  }
}

function getResizerScript() {
  var resizer = function (scriptEnvironment) {
    // only want one resizer on the page
    if (document.documentElement.className.indexOf("g-resizer-v3-init") > -1) return;
    document.documentElement.className += " g-resizer-v3-init";
    // require IE9+
    if (!("querySelector" in document)) return;
    function updateSize() {
      var elements = Array.prototype.slice.call(document.querySelectorAll(".g-artboard-v3[data-min-width]")),
          widthById = {};
      elements.forEach(function(el) {
        var parent = el.parentNode,
            width = widthById[parent.id] || Math.round(parent.getBoundingClientRect().width),
            minwidth = el.getAttribute("data-min-width"),
            maxwidth = el.getAttribute("data-max-width");
        if (parent.id) widthById[parent.id] = width; // only if parent.id is set

        if (+minwidth <= width && (+maxwidth >= width || maxwidth === null)) {
          var img = el.querySelector(".g-aiImg");
          if (img.getAttribute("data-src") && img.getAttribute("src") != img.getAttribute("data-src")) {
            img.setAttribute("src", img.getAttribute("data-src"));
          }
          el.style.display = "block";
        } else {
          el.style.display = "none";
        }
      });

      if (scriptEnvironment=="nyt") {
        try {
          if (window.parent && window.parent.$) {
            window.parent.$("body").trigger("resizedcontent", [window]);
          }
          document.documentElement.dispatchEvent(new Event("resizedcontent"));
          if (window.require && document.querySelector("meta[name=sourceApp]") && document.querySelector("meta[name=sourceApp]").content == "nyt-v5") {
            require(["foundation/main"], function() {
              require(["shared/interactive/instances/app-communicator"], function(AppCommunicator) {
                AppCommunicator.triggerResize();
              });
            });
          }
        } catch(e) { console.log(e); }
      }
    }

    updateSize();
    document.addEventListener("DOMContentLoaded", updateSize);
    // feel free to replace throttle with _.throttle, if available
    window.addEventListener("resize", throttle(updateSize, 200));

    function throttle(func, wait) {
      // from underscore.js
      var _now = Date.now || function() { return new Date().getTime(); },
          context, args, result, timeout = null, previous = 0;
      var later = function() {
          previous = _now();
          timeout = null;
          result = func.apply(context, args);
          if (!timeout) context = args = null;
      };
      return function() {
        var now = _now(), remaining = wait - (now - previous);
        context = this;
        args = arguments;
        if (remaining <= 0 || remaining > wait) {
          if (timeout) {
            clearTimeout(timeout);
            timeout = null;
          }
          previous = now;
          result = func.apply(context, args);
          if (!timeout) context = args = null;
        } else if (!timeout) {
          timeout = setTimeout(later, remaining);
        }
        return result;
      };
    }
  };

  // convert function to JS source code
  var resizerJs = '(' +
    trim(resizer.toString().replace(/  /g, '\t')) + // indent with tabs
    ')("' + scriptEnvironment + '");';
  return '<script type="text/javascript">\n\t' + resizerJs + '\n\t</script>\n\n';
}


// Write an HTML page to a file for NYT Preview
function outputLocalPreviewPage(textForFile, localPreviewDestination, settings) {
  var localPreviewTemplateText = readTextFile(docPath + settings.local_preview_template);
  settings.ai2htmlPartial = textForFile; // TODO: don't modify global settings this way
  var localPreviewHtml = applyTemplate(localPreviewTemplateText, settings);
  saveTextFile(localPreviewDestination, localPreviewHtml);
}

function addCustomContent(content, customBlocks) {
  if (customBlocks.css) {
    content = "\r\t<style type='text/css' media='screen,print'>\r" +
      "\t\t/* Custom CSS */\r\t\t" + customBlocks.css.join('\r\t\t') +
      "\t</style>\r" + content;
  }
  if (customBlocks.html) {
    content += "\r\t<!-- Custom HTML -->\r" + customBlocks.html.join('\r') + '\r';
  }
  // TODO: assumed JS contained in <script> tag -- verify this?
  if (customBlocks.js) {
    content += "\r\t<!-- Custom JS -->\r" + customBlocks.js.join('\r') + '\r';
  }
  return content;
}

// Wrap content HTML in a <div>, add styles and resizer script, write to a file
function generateOutputHtml(pageContent, pageName, settings) {
  var linkSrc = settings.clickable_link || "";
  var textForFile = "";
  var responsiveCss = "";
  var responsiveJs = "";
  var htmlFileDestination, htmlFileDestinationFolder;

  pBar.setTitle('Writing HTML output...');

  if (settings.ai2html_environment == "nyt" && settings.include_resizer_css_js != "no") {
    responsiveJs = '\t<script src="_assets/resizerScript.js"></script>' + "\n";
    if (previewProjectType == "ai2html") {
      responsiveCss = '\t<link rel="stylesheet" href="_assets/resizerStyle.css">' + "\n";
    }
  }
  if (settings.include_resizer_script=="yes") {
    responsiveJs  = '\t' + getResizerScript() + '\n';
    responsiveCss = "";
  }

  // wrap content in a <div> tag
  textForFile += "<div id='" + nameSpace + pageName + "-box' class='ai2html'>\r";

  textForFile += "\t<!-- Generated by ai2html v" + scriptVersion + " - " + getDateTimeStamp() + " -->\r";
  textForFile += "\t<!-- ai file: " + doc.name + " -->\r";
  if (settings.ai2html_environment == "nyt") {
    textForFile += "\t<!-- preview: " + settings.preview_slug + " -->\r";
    textForFile += "\t<!-- scoop  : " + settings.scoop_slug_from_config_yml + " -->\r";
  }
  textForFile += generatePageCss(pageName, settings);

  if (linkSrc) {
    // optional link around content
    textForFile += "\t<a class='" + nameSpace + "ai2htmlLink' href='" + linkSrc + "'>\r";
  }

  textForFile += responsiveCss;
  textForFile += pageContent;
  textForFile += responsiveJs;

  if (linkSrc) {
    textForFile += "\t</a>\r";
  }

  // close <div> wrapper
  textForFile += "\t<!-- End ai2html" + " - " + getDateTimeStamp() + " -->\r</div>\r";

  textForFile = applyTemplate(textForFile, settings);
  htmlFileDestinationFolder = docPath + settings.html_output_path;
  checkForOutputFolder(htmlFileDestinationFolder, "html_output_path");
  htmlFileDestination = htmlFileDestinationFolder + pageName + settings.html_output_extension;

  if (settings.output == 'one-file' && previewProjectType == 'ai2html') {
    htmlFileDestination = htmlFileDestinationFolder + "index" + settings.html_output_extension;
  }

  // write file
  saveTextFile(htmlFileDestination, textForFile);

  // process local preview template if appropriate
  if (settings.local_preview_template !== "") {
    // TODO: may have missed a condition, need to compare with original version
    var previewFileDestination = htmlFileDestinationFolder + pageName + ".preview.html";
    outputLocalPreviewPage(textForFile, previewFileDestination, settings);
  }
}
